package health

import (
	"sync"
	"time"
)

// EventType represents the type of health event.
type EventType int

const (
	EventServiceCrashed EventType = iota
	EventServiceRecovered
	EventServiceStarted
	EventServiceStopped
)

func (e EventType) String() string {
	switch e {
	case EventServiceCrashed:
		return "crashed"
	case EventServiceRecovered:
		return "recovered"
	case EventServiceStarted:
		return "started"
	case EventServiceStopped:
		return "stopped"
	default:
		return "unknown"
	}
}

// Event represents a health state change.
type Event struct {
	Type      EventType
	Project   string
	Service   string
	ExitCode  int // Only for crashed events
	Timestamp time.Time
}

// ServiceState represents the last known state of a service.
type ServiceState struct {
	Running   bool
	ExitCode  int
	Timestamp time.Time
}

// Monitor watches for service state changes.
type Monitor struct {
	states   map[string]ServiceState // key: "project:service"
	events   chan Event
	interval time.Duration
	done     chan struct{}
	mu       sync.RWMutex
	running  bool
}

// NewMonitor creates a health monitor with the given polling interval.
func NewMonitor(interval time.Duration) *Monitor {
	return &Monitor{
		states:   make(map[string]ServiceState),
		events:   make(chan Event, 100), // Buffered to avoid blocking
		interval: interval,
		done:     make(chan struct{}),
	}
}

// Events returns the channel for receiving health events.
func (m *Monitor) Events() <-chan Event {
	return m.events
}

// key generates a unique key for a service.
func key(project, service string) string {
	return project + ":" + service
}

// UpdateService updates the state of a service and emits events if changed.
// Returns any event generated by the state change.
func (m *Monitor) UpdateService(project, service string, running bool, exitCode int) *Event {
	m.mu.Lock()
	defer m.mu.Unlock()

	k := key(project, service)
	prev, exists := m.states[k]

	newState := ServiceState{
		Running:   running,
		ExitCode:  exitCode,
		Timestamp: time.Now(),
	}
	m.states[k] = newState

	if !exists {
		// First time seeing this service
		if running {
			event := Event{
				Type:      EventServiceStarted,
				Project:   project,
				Service:   service,
				Timestamp: time.Now(),
			}
			// Non-blocking send
			select {
			case m.events <- event:
			default:
			}
			return &event
		}
		return nil
	}

	// Check for state transitions
	var event *Event
	if prev.Running && !running {
		// Was running, now stopped
		if exitCode != 0 {
			event = &Event{
				Type:      EventServiceCrashed,
				Project:   project,
				Service:   service,
				ExitCode:  exitCode,
				Timestamp: time.Now(),
			}
		} else {
			event = &Event{
				Type:      EventServiceStopped,
				Project:   project,
				Service:   service,
				Timestamp: time.Now(),
			}
		}
	} else if !prev.Running && running {
		// Was stopped, now running
		event = &Event{
			Type:      EventServiceRecovered,
			Project:   project,
			Service:   service,
			Timestamp: time.Now(),
		}
	}

	if event != nil {
		// Non-blocking send
		select {
		case m.events <- *event:
		default:
		}
	}

	return event
}

// GetState returns the current state of a service.
func (m *Monitor) GetState(project, service string) (ServiceState, bool) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	state, exists := m.states[key(project, service)]
	return state, exists
}

// ClearStates removes all tracked states.
func (m *Monitor) ClearStates() {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.states = make(map[string]ServiceState)
}

// Close shuts down the monitor and closes the events channel.
func (m *Monitor) Close() {
	close(m.done)
	close(m.events)
}
