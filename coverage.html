
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>compose: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/infktd/devdash/internal/compose/client.go (77.4%)</option>
				
				<option value="file1">github.com/infktd/devdash/internal/config/config.go (79.2%)</option>
				
				<option value="file2">github.com/infktd/devdash/internal/config/types.go (100.0%)</option>
				
				<option value="file3">github.com/infktd/devdash/internal/health/monitor.go (95.0%)</option>
				
				<option value="file4">github.com/infktd/devdash/internal/notify/notify.go (100.0%)</option>
				
				<option value="file5">github.com/infktd/devdash/internal/packages/scanner.go (92.3%)</option>
				
				<option value="file6">github.com/infktd/devdash/internal/registry/registry.go (90.7%)</option>
				
				<option value="file7">github.com/infktd/devdash/internal/registry/types.go (41.9%)</option>
				
				<option value="file8">github.com/infktd/devdash/internal/scanner/scanner.go (77.1%)</option>
				
				<option value="file9">github.com/infktd/devdash/internal/ui/alerthistory.go (97.3%)</option>
				
				<option value="file10">github.com/infktd/devdash/internal/ui/alerts.go (45.8%)</option>
				
				<option value="file11">github.com/infktd/devdash/internal/ui/confirm.go (78.8%)</option>
				
				<option value="file12">github.com/infktd/devdash/internal/ui/help.go (97.1%)</option>
				
				<option value="file13">github.com/infktd/devdash/internal/ui/keys.go (100.0%)</option>
				
				<option value="file14">github.com/infktd/devdash/internal/ui/logbuffer.go (91.5%)</option>
				
				<option value="file15">github.com/infktd/devdash/internal/ui/loginterleaver.go (89.5%)</option>
				
				<option value="file16">github.com/infktd/devdash/internal/ui/logview.go (71.9%)</option>
				
				<option value="file17">github.com/infktd/devdash/internal/ui/model.go (34.4%)</option>
				
				<option value="file18">github.com/infktd/devdash/internal/ui/packages.go (87.3%)</option>
				
				<option value="file19">github.com/infktd/devdash/internal/ui/progress.go (96.0%)</option>
				
				<option value="file20">github.com/infktd/devdash/internal/ui/settings.go (89.7%)</option>
				
				<option value="file21">github.com/infktd/devdash/internal/ui/splash.go (98.6%)</option>
				
				<option value="file22">github.com/infktd/devdash/internal/ui/styles.go (100.0%)</option>
				
				<option value="file23">github.com/infktd/devdash/internal/ui/theme.go (100.0%)</option>
				
				<option value="file24">github.com/infktd/devdash/internal/ui/toast.go (93.8%)</option>
				
				<option value="file25">github.com/infktd/devdash/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package compose provides a client for the process-compose REST API.
package compose

import (
        "context"
        "encoding/json"
        "fmt"
        "net"
        "net/http"
        "time"
)

// Client communicates with process-compose via Unix socket.
type Client struct {
        socketPath string
        httpClient *http.Client
        connected  bool
}

// NewClient creates a new process-compose client.
func NewClient(socketPath string) *Client <span class="cov8" title="1">{
        return &amp;Client{
                socketPath: socketPath,
                httpClient: &amp;http.Client{
                        Transport: &amp;http.Transport{
                                DialContext: func(ctx context.Context, _, _ string) (net.Conn, error) </span><span class="cov8" title="1">{
                                        return net.Dial("unix", socketPath)
                                }</span>,
                        },
                        Timeout: 5 * time.Second,
                },
        }
}

// Connect attempts to connect to the process-compose socket.
func (c *Client) Connect() error <span class="cov8" title="1">{
        conn, err := net.Dial("unix", c.socketPath)
        if err != nil </span><span class="cov8" title="1">{
                c.connected = false
                return err
        }</span>
        <span class="cov8" title="1">conn.Close()
        c.connected = true
        return nil</span>
}

// IsConnected returns true if connected to process-compose.
func (c *Client) IsConnected() bool <span class="cov8" title="1">{
        return c.connected
}</span>

// GetStatus fetches the current process status.
func (c *Client) GetStatus() (*ProjectStatus, error) <span class="cov8" title="1">{
        resp, err := c.httpClient.Get("http://unix/processes")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected status: %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">var apiResp processesResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;apiResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;ProjectStatus{Processes: apiResp.Data}, nil</span>
}

// StartProcess starts a specific process.
func (c *Client) StartProcess(name string) error <span class="cov8" title="1">{
        url := fmt.Sprintf("http://unix/process/%s/start", name)
        resp, err := c.httpClient.Post(url, "application/json", nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start process: %d", resp.StatusCode)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// StopProcess stops a specific process.
func (c *Client) StopProcess(name string) error <span class="cov8" title="1">{
        url := fmt.Sprintf("http://unix/process/%s/stop", name)
        resp, err := c.httpClient.Post(url, "application/json", nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to stop process: %d", resp.StatusCode)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// RestartProcess restarts a specific process.
func (c *Client) RestartProcess(name string) error <span class="cov8" title="1">{
        url := fmt.Sprintf("http://unix/process/%s/restart", name)
        resp, err := c.httpClient.Post(url, "application/json", nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restart process: %d", resp.StatusCode)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ShutdownProject stops all processes and shuts down.
func (c *Client) ShutdownProject() error <span class="cov8" title="1">{
        resp, err := c.httpClient.Post("http://unix/project/stop", "application/json", nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to shutdown: %d", resp.StatusCode)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetLogs fetches recent logs for a process.
// endOffset is offset from end (0 = most recent), limit is max lines to return.
func (c *Client) GetLogs(processName string, endOffset, limit int) ([]string, error) <span class="cov8" title="1">{
        url := fmt.Sprintf("http://unix/process/logs/%s/%d/%d", processName, endOffset, limit)
        resp, err := c.httpClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get logs: %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">var logsResp logsResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;logsResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return logsResp.Logs, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package config handles devdash configuration loading and persistence.
package config

import (
        "os"
        "path/filepath"

        "gopkg.in/yaml.v3"
)

const (
        configDir  = "devdash"
        configFile = "config.yaml"
)

// Path returns the default config file path.
func Path() string <span class="cov8" title="1">{
        configHome := os.Getenv("XDG_CONFIG_HOME")
        if configHome == "" </span><span class="cov8" title="1">{
                home, _ := os.UserHomeDir()
                configHome = filepath.Join(home, ".config")
        }</span>
        <span class="cov8" title="1">return filepath.Join(configHome, configDir, configFile)</span>
}

// Load reads config from path, creating default if missing.
func Load(path string) (*Config, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                cfg := Default()
                if err := Save(path, cfg); err != nil </span><span class="cov0" title="0">{
                        return cfg, nil // Return default even if save fails
                }</span>
                <span class="cov8" title="1">return cfg, nil</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">cfg := Default() // Start with defaults
        if err := yaml.Unmarshal(data, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return cfg, nil</span>
}

// Save writes config to path, creating directories as needed.
func Save(path string, cfg *Config) error <span class="cov8" title="1">{
        dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">data, err := yaml.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return os.WriteFile(path, data, 0644)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "os"
        "path/filepath"
)

// Config represents the devdash configuration.
type Config struct {
        Projects      ProjectsConfig      `yaml:"projects"`
        Notifications NotificationsConfig `yaml:"notifications"`
        UI            UIConfig            `yaml:"ui"`
        Polling       PollingConfig       `yaml:"polling"`
}

// ProjectsConfig configures project discovery.
type ProjectsConfig struct {
        ScanPaths    []string `yaml:"scan_paths"`
        AutoDiscover bool     `yaml:"auto_discover"`
        ScanDepth    int      `yaml:"scan_depth"`
}

// NotificationsConfig configures alerts and notifications.
type NotificationsConfig struct {
        SystemEnabled bool                   `yaml:"system_enabled"`
        TUIAlerts     bool                   `yaml:"tui_alerts"`
        CriticalOnly  bool                   `yaml:"critical_only"`
        Overrides     []NotificationOverride `yaml:"overrides,omitempty"`
}

// NotificationOverride allows per-service notification settings.
type NotificationOverride struct {
        Service      string `yaml:"service"`
        System       bool   `yaml:"system"`
        CriticalOnly bool   `yaml:"critical_only,omitempty"`
}

// UIConfig configures the user interface.
type UIConfig struct {
        Theme          string `yaml:"theme"`
        DefaultLogView string `yaml:"default_log_view"`
        LogFollow      bool   `yaml:"log_follow"`
        ShowTimestamps bool   `yaml:"show_timestamps"`
        DimTimestamps  bool   `yaml:"dim_timestamps"`
        SidebarWidth   int    `yaml:"sidebar_width"`
}

// PollingConfig configures polling intervals in seconds.
type PollingConfig struct {
        FocusedProject    int `yaml:"focused_project"`
        BackgroundProject int `yaml:"background_project"`
}

// Default returns a Config with sensible defaults.
func Default() *Config <span class="cov8" title="1">{
        scanPaths := []string{}
        home, err := os.UserHomeDir()
        if err == nil </span><span class="cov8" title="1">{
                scanPaths = []string{
                        filepath.Join(home, "code"),
                        filepath.Join(home, "projects"),
                }
        }</span>
        <span class="cov8" title="1">return &amp;Config{
                Projects: ProjectsConfig{
                        ScanPaths:    scanPaths,
                        AutoDiscover: true,
                        ScanDepth:    3,
                },
                Notifications: NotificationsConfig{
                        SystemEnabled: true,
                        TUIAlerts:     true,
                        CriticalOnly:  false,
                },
                UI: UIConfig{
                        Theme:          "matrix",
                        DefaultLogView: "focused",
                        LogFollow:      true,
                        ShowTimestamps: true,
                        DimTimestamps:  true,
                        SidebarWidth:   25,
                },
                Polling: PollingConfig{
                        FocusedProject:    2,
                        BackgroundProject: 10,
                },
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package health

import (
        "sync"
        "time"
)

// EventType represents the type of health event.
type EventType int

const (
        EventServiceCrashed EventType = iota
        EventServiceRecovered
        EventServiceStarted
        EventServiceStopped
)

func (e EventType) String() string <span class="cov8" title="1">{
        switch e </span>{
        case EventServiceCrashed:<span class="cov8" title="1">
                return "crashed"</span>
        case EventServiceRecovered:<span class="cov8" title="1">
                return "recovered"</span>
        case EventServiceStarted:<span class="cov8" title="1">
                return "started"</span>
        case EventServiceStopped:<span class="cov8" title="1">
                return "stopped"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// Event represents a health state change.
type Event struct {
        Type      EventType
        Project   string
        Service   string
        ExitCode  int // Only for crashed events
        Timestamp time.Time
}

// ServiceState represents the last known state of a service.
type ServiceState struct {
        Running   bool
        ExitCode  int
        Timestamp time.Time
}

// Monitor watches for service state changes.
type Monitor struct {
        states   map[string]ServiceState // key: "project:service"
        events   chan Event
        interval time.Duration
        done     chan struct{}
        mu       sync.RWMutex
        running  bool
}

// NewMonitor creates a health monitor with the given polling interval.
func NewMonitor(interval time.Duration) *Monitor <span class="cov8" title="1">{
        return &amp;Monitor{
                states:   make(map[string]ServiceState),
                events:   make(chan Event, 100), // Buffered to avoid blocking
                interval: interval,
                done:     make(chan struct{}),
        }
}</span>

// Events returns the channel for receiving health events.
func (m *Monitor) Events() &lt;-chan Event <span class="cov8" title="1">{
        return m.events
}</span>

// key generates a unique key for a service.
func key(project, service string) string <span class="cov8" title="1">{
        return project + ":" + service
}</span>

// UpdateService updates the state of a service and emits events if changed.
// Returns any event generated by the state change.
func (m *Monitor) UpdateService(project, service string, running bool, exitCode int) *Event <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        k := key(project, service)
        prev, exists := m.states[k]

        newState := ServiceState{
                Running:   running,
                ExitCode:  exitCode,
                Timestamp: time.Now(),
        }
        m.states[k] = newState

        if !exists </span><span class="cov8" title="1">{
                // First time seeing this service
                if running </span><span class="cov8" title="1">{
                        event := Event{
                                Type:      EventServiceStarted,
                                Project:   project,
                                Service:   service,
                                Timestamp: time.Now(),
                        }
                        // Non-blocking send
                        select </span>{
                        case m.events &lt;- event:<span class="cov8" title="1"></span>
                        default:<span class="cov0" title="0"></span>
                        }
                        <span class="cov8" title="1">return &amp;event</span>
                }
                <span class="cov0" title="0">return nil</span>
        }

        // Check for state transitions
        <span class="cov8" title="1">var event *Event
        if prev.Running &amp;&amp; !running </span><span class="cov8" title="1">{
                // Was running, now stopped
                if exitCode != 0 </span><span class="cov8" title="1">{
                        event = &amp;Event{
                                Type:      EventServiceCrashed,
                                Project:   project,
                                Service:   service,
                                ExitCode:  exitCode,
                                Timestamp: time.Now(),
                        }
                }</span> else<span class="cov8" title="1"> {
                        event = &amp;Event{
                                Type:      EventServiceStopped,
                                Project:   project,
                                Service:   service,
                                Timestamp: time.Now(),
                        }
                }</span>
        } else<span class="cov8" title="1"> if !prev.Running &amp;&amp; running </span><span class="cov8" title="1">{
                // Was stopped, now running
                event = &amp;Event{
                        Type:      EventServiceRecovered,
                        Project:   project,
                        Service:   service,
                        Timestamp: time.Now(),
                }
        }</span>

        <span class="cov8" title="1">if event != nil </span><span class="cov8" title="1">{
                // Non-blocking send
                select </span>{
                case m.events &lt;- *event:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0"></span>
                }
        }

        <span class="cov8" title="1">return event</span>
}

// GetState returns the current state of a service.
func (m *Monitor) GetState(project, service string) (ServiceState, bool) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        state, exists := m.states[key(project, service)]
        return state, exists
}</span>

// ClearStates removes all tracked states.
func (m *Monitor) ClearStates() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.states = make(map[string]ServiceState)
}</span>

// Close shuts down the monitor and closes the events channel.
func (m *Monitor) Close() <span class="cov8" title="1">{
        close(m.done)
        close(m.events)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package notify

import (
        "fmt"

        "github.com/gen2brain/beeep"
)

// Notifier handles system notifications.
type Notifier struct {
        enabled bool
}

// NewNotifier creates a system notifier.
func NewNotifier(enabled bool) *Notifier <span class="cov8" title="1">{
        return &amp;Notifier{enabled: enabled}
}</span>

// SetEnabled enables or disables notifications.
func (n *Notifier) SetEnabled(enabled bool) <span class="cov8" title="1">{
        n.enabled = enabled
}</span>

// IsEnabled returns whether notifications are enabled.
func (n *Notifier) IsEnabled() bool <span class="cov8" title="1">{
        return n.enabled
}</span>

// ServiceCrashed sends a notification for a crashed service.
func (n *Notifier) ServiceCrashed(project, service string, exitCode int) error <span class="cov8" title="1">{
        if !n.enabled </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">title := "acidBurn: Service Crashed"
        body := fmt.Sprintf("%s in %s exited with code %d", service, project, exitCode)
        return beeep.Alert(title, body, "")</span>
}

// ServiceRecovered sends a notification for a recovered service.
func (n *Notifier) ServiceRecovered(project, service string) error <span class="cov8" title="1">{
        if !n.enabled </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">title := "acidBurn: Service Recovered"
        body := fmt.Sprintf("%s in %s is now running", service, project)
        return beeep.Notify(title, body, "")</span>
}

// ProjectStarted sends a notification when a project starts.
func (n *Notifier) ProjectStarted(project string) error <span class="cov8" title="1">{
        if !n.enabled </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">title := "acidBurn: Project Started"
        body := fmt.Sprintf("%s is now running", project)
        return beeep.Notify(title, body, "")</span>
}

// ProjectStopped sends a notification when a project stops.
func (n *Notifier) ProjectStopped(project string) error <span class="cov8" title="1">{
        if !n.enabled </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">title := "acidBurn: Project Stopped"
        body := fmt.Sprintf("%s has been stopped", project)
        return beeep.Notify(title, body, "")</span>
}

// Critical sends a critical alert (e.g., Nix daemon down).
func (n *Notifier) Critical(title, message string) error <span class="cov8" title="1">{
        if !n.enabled </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return beeep.Alert(title, message, "")</span>
}

// Info sends an informational notification.
func (n *Notifier) Info(title, message string) error <span class="cov8" title="1">{
        if !n.enabled </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return beeep.Notify(title, message, "")</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package packages

import (
        "io/fs"
        "os"
        "path/filepath"
        "regexp"
        "strings"
)

// nixStoreRegex parses Nix store path components.
// Pattern explanation:
// - ^([a-z0-9]+) - matches the hash at the start (group 1)
// - -(.+?) - matches the package name, non-greedy to allow backtracking (group 2)
// - (?:-([0-9]+[0-9.\-a-z]*))? - optionally matches version starting with a digit (group 3)
//   * Must start with a digit to distinguish from hyphenated package names
//   * Can contain digits, dots, hyphens, and letters (e.g., "1.21.5", "0.14.0-unstable")
//   * Optional group allows packages without versions
//
// Examples:
//   - "abc123-go-1.21.5" → hash="abc123", name="go", version="1.21.5"
//   - "xyz789-gcc-arm-embedded-13.2.1" → hash="xyz789", name="gcc-arm-embedded", version="13.2.1"
//   - "def456-bash" → hash="def456", name="bash", version=""
var nixStoreRegex = regexp.MustCompile(`^([a-z0-9]+)-(.+?)(?:-([0-9]+[0-9.\-a-z]*))?$`)

// parseNixStorePath extracts package name, version, and hash from a Nix store path.
// Format: /nix/store/&lt;hash&gt;-&lt;name&gt;-&lt;version&gt;/...
// Returns: (name, version, hash)
func parseNixStorePath(path string) (string, string, string) <span class="cov8" title="1">{
        // Get the store directory component
        // e.g., /nix/store/abc123-go-1.21.5/bin/go -&gt; abc123-go-1.21.5
        parts := strings.Split(filepath.Clean(path), string(filepath.Separator))

        var storeComponent string
        for i, part := range parts </span><span class="cov8" title="1">{
                if part == "store" &amp;&amp; i+1 &lt; len(parts) </span><span class="cov8" title="1">{
                        storeComponent = parts[i+1]
                        break</span>
                }
        }

        <span class="cov8" title="1">if storeComponent == "" </span><span class="cov8" title="1">{
                return "", "", ""
        }</span>

        // Parse: &lt;hash&gt;-&lt;name&gt;-&lt;version&gt;
        <span class="cov8" title="1">matches := nixStoreRegex.FindStringSubmatch(storeComponent)

        if len(matches) &lt; 3 </span><span class="cov8" title="1">{
                // Fallback: just hash-name format
                firstDashIndex := strings.Index(storeComponent, "-")
                if firstDashIndex &gt; 0 </span><span class="cov0" title="0">{
                        return storeComponent[firstDashIndex+1:], "", storeComponent[:firstDashIndex]
                }</span>
                <span class="cov8" title="1">return storeComponent, "", ""</span>
        }

        <span class="cov8" title="1">hash := matches[1]
        name := matches[2]
        version := matches[3] // Will be empty string if group didn't match

        return name, version, hash</span>
}

// categorizePackage determines the package type based on name patterns.
// Uses exact matches for core tools and explicit checks for known variants
// to avoid false positives (e.g., "golang" or "google-chrome" shouldn't match "go").
//
// Examples:
//   - categorizePackage("go") → "Go"
//   - categorizePackage("python3") → "Python"
//   - categorizePackage("node") → "Node.js"
//   - categorizePackage("golang") → "Other" (not the Go toolchain)
//   - categorizePackage("python-dotenv") → "Other" (Python package, not Python itself)
func categorizePackage(name string) string <span class="cov8" title="1">{
        lowerName := strings.ToLower(name)

        // Go packages - exact match for "go" + known Go toolchain binaries
        if lowerName == "go" ||
                lowerName == "gopls" ||
                lowerName == "gofmt" ||
                lowerName == "godoc" ||
                lowerName == "goimports" ||
                lowerName == "golangci-lint" </span><span class="cov8" title="1">{
                return "Go"
        }</span>

        // Python packages - exact match for python/python2/python3 + known Python tools
        <span class="cov8" title="1">if lowerName == "python" ||
                lowerName == "python2" ||
                lowerName == "python3" ||
                lowerName == "pip" ||
                lowerName == "pip2" ||
                lowerName == "pip3" ||
                lowerName == "pytest" ||
                lowerName == "poetry" ||
                lowerName == "pipenv" </span><span class="cov8" title="1">{
                return "Python"
        }</span>

        // Node.js packages - exact matches for Node ecosystem tools
        <span class="cov8" title="1">if lowerName == "node" ||
                lowerName == "nodejs" ||
                lowerName == "npm" ||
                lowerName == "npx" ||
                lowerName == "yarn" ||
                lowerName == "pnpm" </span><span class="cov8" title="1">{
                return "Node.js"
        }</span>

        // Rust packages - exact matches for Rust toolchain
        <span class="cov8" title="1">if lowerName == "cargo" ||
                lowerName == "rustc" ||
                lowerName == "rustup" ||
                lowerName == "rustfmt" </span><span class="cov8" title="1">{
                return "Rust"
        }</span>

        // C/C++ compilers - exact matches
        <span class="cov8" title="1">if lowerName == "gcc" ||
                lowerName == "g++" ||
                lowerName == "clang" ||
                lowerName == "clang++" ||
                lowerName == "make" ||
                lowerName == "cmake" </span><span class="cov8" title="1">{
                return "C/C++"
        }</span>

        // Ruby - exact matches
        <span class="cov8" title="1">if lowerName == "ruby" ||
                lowerName == "gem" ||
                lowerName == "bundle" ||
                lowerName == "bundler" ||
                lowerName == "rake" </span><span class="cov8" title="1">{
                return "Ruby"
        }</span>

        // Java - exact matches
        <span class="cov8" title="1">if lowerName == "java" ||
                lowerName == "javac" ||
                lowerName == "maven" ||
                lowerName == "mvn" ||
                lowerName == "gradle" </span><span class="cov8" title="1">{
                return "Java"
        }</span>

        <span class="cov8" title="1">return "Other"</span>
}

// binaryInfo holds parsed information about a binary.
type binaryInfo struct {
        name    string
        version string
        hash    string
        path    string
}

// Scan discovers packages in a devenv project.
// Returns list of packages found, or empty list if directory doesn't exist.
func Scan(projectPath string) ([]Package, error) <span class="cov8" title="1">{
        binDir := filepath.Join(projectPath, ".devenv", "profile", "bin")

        // Check if bin directory exists
        if _, err := os.Stat(binDir); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return []Package{}, nil
        }</span>

        <span class="cov8" title="1">var binaries []binaryInfo

        // Read all files in bin directory
        err := filepath.WalkDir(binDir, func(path string, d fs.DirEntry, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil // Skip errors
                }</span>

                // Skip directories and the bin directory itself
                <span class="cov8" title="1">if d.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // Resolve symlink to find Nix store path
                <span class="cov8" title="1">target, err := os.Readlink(path)
                if err != nil </span><span class="cov8" title="1">{
                        // Not a symlink, use the file path itself
                        target = path
                }</span>

                // Parse Nix store path
                <span class="cov8" title="1">name, version, hash := parseNixStorePath(target)
                if name == "" </span><span class="cov8" title="1">{
                        // Couldn't parse, skip
                        return nil
                }</span>

                <span class="cov0" title="0">binaries = append(binaries, binaryInfo{
                        name:    name,
                        version: version,
                        hash:    hash,
                        path:    path,
                })

                return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return []Package{}, err
        }</span>

        // Group binaries by package
        <span class="cov8" title="1">packages := groupByPackage(binaries)

        return packages, nil</span>
}

// groupByPackage groups binaries from the same Nix package.
// Binaries with the same hash+version belong to the same package.
func groupByPackage(binaries []binaryInfo) []Package <span class="cov8" title="1">{
        // Use map to group by package identifier (hash-version)
        // Same hash+version = same Nix package, even if binary names differ
        packageMap := make(map[string]*Package)

        for _, bin := range binaries </span><span class="cov8" title="1">{
                // Create unique package identifier based on hash and version only
                // This groups go, gofmt, godoc etc. from the same Go installation
                pkgID := bin.hash + "-" + bin.version

                if _, exists := packageMap[pkgID]; exists </span><span class="cov8" title="1">{
                        // Package already seen, skip this binary
                        continue</span>
                }

                // New package - use the binary name as the package name
                <span class="cov8" title="1">packageMap[pkgID] = &amp;Package{
                        Name:    bin.name,
                        Version: bin.version,
                        Type:    categorizePackage(bin.name),
                        Binary:  bin.path,
                }</span>
        }

        // Convert map to slice
        <span class="cov8" title="1">packages := make([]Package, 0, len(packageMap))
        for _, pkg := range packageMap </span><span class="cov8" title="1">{
                packages = append(packages, *pkg)
        }</span>

        <span class="cov8" title="1">return packages</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package registry manages the project registry and discovery state.
package registry

import (
        "os"
        "path/filepath"

        "gopkg.in/yaml.v3"
)

const (
        registryDir  = "devdash"
        registryFile = "projects.yaml"
)

// Registry holds discovered projects.
type Registry struct {
        Projects []*Project `yaml:"projects"`
}

// Path returns the default registry file path.
func Path() string <span class="cov8" title="1">{
        configHome := os.Getenv("XDG_CONFIG_HOME")
        if configHome == "" </span><span class="cov8" title="1">{
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        // Fallback to current directory if home can't be determined
                        configHome = ".config"
                }</span> else<span class="cov8" title="1"> {
                        configHome = filepath.Join(home, ".config")
                }</span>
        }
        <span class="cov8" title="1">return filepath.Join(configHome, registryDir, registryFile)</span>
}

// Load reads the registry from path.
func Load(path string) (*Registry, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return &amp;Registry{Projects: []*Project{}}, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var reg Registry
        if err := yaml.Unmarshal(data, &amp;reg); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;reg, nil</span>
}

// Save writes the registry to path.
func Save(path string, reg *Registry) error <span class="cov8" title="1">{
        dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">data, err := yaml.Marshal(reg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return os.WriteFile(path, data, 0644)</span>
}

// AddProject adds a project if not already present.
func (r *Registry) AddProject(path string) *Project <span class="cov8" title="1">{
        for _, p := range r.Projects </span><span class="cov8" title="1">{
                if p.Path == path </span><span class="cov8" title="1">{
                        return p
                }</span>
        }
        <span class="cov8" title="1">p := NewProject(path)
        r.Projects = append(r.Projects, p)
        return p</span>
}

// FindByPath returns a project by its path.
func (r *Registry) FindByPath(path string) *Project <span class="cov8" title="1">{
        for _, p := range r.Projects </span><span class="cov8" title="1">{
                if p.Path == path </span><span class="cov8" title="1">{
                        return p
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// RemoveProject removes a project from the registry.
func (r *Registry) RemoveProject(path string) bool <span class="cov8" title="1">{
        for i, p := range r.Projects </span><span class="cov8" title="1">{
                if p.Path == path </span><span class="cov8" title="1">{
                        r.Projects = append(r.Projects[:i], r.Projects[i+1:]...)
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// ToggleHidden toggles the hidden state of a project.
func (r *Registry) ToggleHidden(path string) bool <span class="cov8" title="1">{
        p := r.FindByPath(path)
        if p != nil </span><span class="cov8" title="1">{
                p.Hidden = !p.Hidden
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package registry

import (
        "crypto/sha256"
        "encoding/hex"
        "net"
        "os"
        "path/filepath"
        "time"

        "github.com/infktd/devdash/internal/compose"
)

// ProjectState represents the current state of a project.
type ProjectState int

const (
        StateIdle ProjectState = iota
        StateRunning
        StateDegraded
        StateStale
        StateMissing
)

func (s ProjectState) String() string <span class="cov8" title="1">{
        switch s </span>{
        case StateIdle:<span class="cov8" title="1">
                return "idle"</span>
        case StateRunning:<span class="cov8" title="1">
                return "running"</span>
        case StateDegraded:<span class="cov8" title="1">
                return "degraded"</span>
        case StateStale:<span class="cov8" title="1">
                return "stale"</span>
        case StateMissing:<span class="cov8" title="1">
                return "missing"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// Project represents a devenv project in the registry.
type Project struct {
        ID         string    `yaml:"id"`
        Path       string    `yaml:"path"`
        Name       string    `yaml:"name"`
        Hidden     bool      `yaml:"hidden"`
        LastActive time.Time `yaml:"last_active"`
}

// NewProject creates a new Project from a path.
func NewProject(path string) *Project <span class="cov8" title="1">{
        // Generate ID from path hash
        hash := sha256.Sum256([]byte(path))
        id := hex.EncodeToString(hash[:8])

        return &amp;Project{
                ID:         id,
                Path:       path,
                Name:       filepath.Base(path),
                Hidden:     false,
                LastActive: time.Now(),
        }
}</span>

// SocketPath returns the path to the process-compose socket.
// devenv creates a symlink at .devenv/run pointing to /run/user/$UID/devenv-$HASH
func (p *Project) SocketPath() string <span class="cov8" title="1">{
        return filepath.Join(p.Path, ".devenv", "run", "pc.sock")
}</span>

// DetectState checks the project's current state.
func (p *Project) DetectState() ProjectState <span class="cov8" title="1">{
        // Check if path exists
        if _, err := os.Stat(p.Path); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return StateMissing
        }</span>

        <span class="cov8" title="1">socketPath := p.SocketPath()

        // Try to connect to socket
        conn, err := net.Dial("unix", socketPath)
        if err == nil </span><span class="cov0" title="0">{
                conn.Close()
                // Socket is reachable, query API to check service states
                return p.checkServiceStates()
        }</span>

        // Check if socket file exists (stale)
        <span class="cov8" title="1">if _, err := os.Stat(socketPath); err == nil </span><span class="cov0" title="0">{
                return StateStale
        }</span>

        <span class="cov8" title="1">return StateIdle</span>
}

// checkServiceStates queries the compose API to determine if the project is running or degraded.
func (p *Project) checkServiceStates() ProjectState <span class="cov0" title="0">{
        client := compose.NewClient(p.SocketPath())
        if err := client.Connect(); err != nil </span><span class="cov0" title="0">{
                // Can't connect, consider it idle
                return StateIdle
        }</span>

        <span class="cov0" title="0">status, err := client.GetStatus()
        if err != nil </span><span class="cov0" title="0">{
                // API error, assume running since socket was reachable
                return StateRunning
        }</span>

        // Count running and total processes
        <span class="cov0" title="0">runningCount := 0
        totalCount := len(status.Processes)

        for _, proc := range status.Processes </span><span class="cov0" title="0">{
                if proc.IsRunning </span><span class="cov0" title="0">{
                        runningCount++
                }</span>
        }

        // If no processes, consider idle
        <span class="cov0" title="0">if totalCount == 0 </span><span class="cov0" title="0">{
                return StateIdle
        }</span>

        // If all processes running, fully operational
        <span class="cov0" title="0">if runningCount == totalCount </span><span class="cov0" title="0">{
                return StateRunning
        }</span>

        // If some processes running, degraded
        <span class="cov0" title="0">if runningCount &gt; 0 </span><span class="cov0" title="0">{
                return StateDegraded
        }</span>

        // No processes running but socket exists
        <span class="cov0" title="0">return StateStale</span>
}

// Repair cleans up stale socket files and symlinks.
func (p *Project) Repair() error <span class="cov0" title="0">{
        runDir := filepath.Join(p.Path, ".devenv", "run")

        // Remove the entire run directory (contains socket and symlink)
        if err := os.RemoveAll(runDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package scanner discovers devenv.nix projects on the filesystem.
package scanner

import (
        "io/fs"
        "os"
        "path/filepath"
        "strings"
)

// Directories to skip during scanning.
var excludedDirs = map[string]bool{
        "node_modules": true,
        ".git":         true,
        ".direnv":      true,
        "dist":         true,
        "target":       true,
        "vendor":       true,
        ".venv":        true,
        "__pycache__":  true,
}

// Scan searches paths for directories containing devenv.nix.
// maxDepth limits how deep to recurse (1 = immediate children only).
func Scan(paths []string, maxDepth int) ([]string, error) <span class="cov8" title="1">{
        var projects []string
        seen := make(map[string]bool)

        for _, root := range paths </span><span class="cov8" title="1">{
                // Expand ~ if present
                if strings.HasPrefix(root, "~/") </span><span class="cov0" title="0">{
                        home, err := os.UserHomeDir()
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span> // Skip paths we can't expand
                        }
                        <span class="cov0" title="0">root = filepath.Join(home, root[2:])</span>
                }

                <span class="cov8" title="1">err := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error </span><span class="cov8" title="1">{
                        if err != nil </span><span class="cov0" title="0">{
                                return nil // Skip inaccessible paths
                        }</span>

                        // Calculate depth relative to root
                        <span class="cov8" title="1">rel, err := filepath.Rel(root, path)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil // Skip paths with invalid relative paths
                        }</span>
                        <span class="cov8" title="1">depth := len(strings.Split(rel, string(os.PathSeparator)))
                        if rel == "." </span><span class="cov8" title="1">{
                                depth = 0
                        }</span>

                        // For directories, skip if too deep
                        <span class="cov8" title="1">if d.IsDir() </span><span class="cov8" title="1">{
                                if depth &gt; maxDepth </span><span class="cov8" title="1">{
                                        return fs.SkipDir
                                }</span>
                                // Skip excluded directories
                                <span class="cov8" title="1">if excludedDirs[d.Name()] </span><span class="cov8" title="1">{
                                        return fs.SkipDir
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        }

                        // For files, check depth of parent directory (depth - 1)
                        <span class="cov8" title="1">parentDepth := depth - 1
                        if parentDepth &gt; maxDepth </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        // Check for devenv.nix
                        <span class="cov8" title="1">if d.Name() == "devenv.nix" </span><span class="cov8" title="1">{
                                projectPath := filepath.Dir(path)
                                if !seen[projectPath] </span><span class="cov8" title="1">{
                                        seen[projectPath] = true
                                        projects = append(projects, projectPath)
                                }</span>
                        }

                        <span class="cov8" title="1">return nil</span>
                })
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return projects, err
                }</span>
        }

        <span class="cov8" title="1">return projects, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package ui

import (
        "fmt"
        "sync"
        "time"
)

// AlertType represents the type of alert.
type AlertType int

const (
        AlertServiceCrashed AlertType = iota
        AlertServiceRecovered
        AlertProjectStarted
        AlertProjectStopped
        AlertCritical
        AlertInfo
)

func (t AlertType) String() string <span class="cov8" title="1">{
        switch t </span>{
        case AlertServiceCrashed:<span class="cov8" title="1">
                return "crashed"</span>
        case AlertServiceRecovered:<span class="cov8" title="1">
                return "recovered"</span>
        case AlertProjectStarted:<span class="cov8" title="1">
                return "started"</span>
        case AlertProjectStopped:<span class="cov8" title="1">
                return "stopped"</span>
        case AlertCritical:<span class="cov8" title="1">
                return "critical"</span>
        case AlertInfo:<span class="cov8" title="1">
                return "info"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// Alert represents a stored alert.
type Alert struct {
        Type      AlertType
        Project   string
        Service   string // May be empty for project-level alerts
        Message   string
        Timestamp time.Time
}

// AlertHistory stores past alerts.
type AlertHistory struct {
        alerts   []Alert
        capacity int
        mu       sync.RWMutex
}

// NewAlertHistory creates a new alert history with given capacity.
func NewAlertHistory(capacity int) *AlertHistory <span class="cov8" title="1">{
        return &amp;AlertHistory{
                alerts:   make([]Alert, 0, capacity),
                capacity: capacity,
        }
}</span>

// Add appends an alert, removing oldest if at capacity.
func (h *AlertHistory) Add(alert Alert) <span class="cov8" title="1">{
        h.mu.Lock()
        defer h.mu.Unlock()

        if len(h.alerts) &gt;= h.capacity </span><span class="cov8" title="1">{
                // Remove oldest (first element)
                h.alerts = h.alerts[1:]
        }</span>
        <span class="cov8" title="1">h.alerts = append(h.alerts, alert)</span>
}

// AddServiceCrashed is a convenience method.
func (h *AlertHistory) AddServiceCrashed(project, service string, exitCode int) <span class="cov8" title="1">{
        h.Add(Alert{
                Type:      AlertServiceCrashed,
                Project:   project,
                Service:   service,
                Message:   fmt.Sprintf("exited with code %d", exitCode),
                Timestamp: time.Now(),
        })
}</span>

// AddServiceRecovered is a convenience method.
func (h *AlertHistory) AddServiceRecovered(project, service string) <span class="cov8" title="1">{
        h.Add(Alert{
                Type:      AlertServiceRecovered,
                Project:   project,
                Service:   service,
                Message:   "recovered",
                Timestamp: time.Now(),
        })
}</span>

// All returns all alerts (newest last).
func (h *AlertHistory) All() []Alert <span class="cov8" title="1">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        result := make([]Alert, len(h.alerts))
        copy(result, h.alerts)
        return result
}</span>

// Recent returns the most recent n alerts (newest first).
func (h *AlertHistory) Recent(n int) []Alert <span class="cov8" title="1">{
        h.mu.RLock()
        defer h.mu.RUnlock()

        if n &gt; len(h.alerts) </span><span class="cov8" title="1">{
                n = len(h.alerts)
        }</span>
        <span class="cov8" title="1">if n == 0 </span><span class="cov8" title="1">{
                return []Alert{}
        }</span>

        <span class="cov8" title="1">result := make([]Alert, n)
        // Copy from end to beginning (reverse order)
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                result[i] = h.alerts[len(h.alerts)-1-i]
        }</span>
        <span class="cov8" title="1">return result</span>
}

// Len returns the number of alerts.
func (h *AlertHistory) Len() int <span class="cov8" title="1">{
        h.mu.RLock()
        defer h.mu.RUnlock()
        return len(h.alerts)
}</span>

// Clear removes all alerts.
func (h *AlertHistory) Clear() <span class="cov8" title="1">{
        h.mu.Lock()
        defer h.mu.Unlock()
        h.alerts = make([]Alert, 0, h.capacity)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package ui

import (
        "fmt"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// AlertsPanel manages the alerts modal.
type AlertsPanel struct {
        styles  *Styles
        alerts  *AlertHistory
        visible bool
        width   int
        height  int
}

// NewAlertsPanel creates an alerts panel.
func NewAlertsPanel(styles *Styles, alerts *AlertHistory, width, height int) *AlertsPanel <span class="cov8" title="1">{
        return &amp;AlertsPanel{
                styles:  styles,
                alerts:  alerts,
                visible: false,
                width:   width,
                height:  height,
        }
}</span>

// Show makes the alerts panel visible.
func (a *AlertsPanel) Show() <span class="cov8" title="1">{
        a.visible = true
}</span>

// Hide closes the alerts panel.
func (a *AlertsPanel) Hide() <span class="cov8" title="1">{
        a.visible = false
}</span>

// IsVisible returns whether the panel is shown.
func (a *AlertsPanel) IsVisible() bool <span class="cov8" title="1">{
        return a.visible
}</span>

// SetSize updates the panel dimensions.
func (a *AlertsPanel) SetSize(width, height int) <span class="cov8" title="1">{
        a.width = width
        a.height = height
}</span>

// Update handles input for the alerts panel.
func (a *AlertsPanel) Update(msg tea.Msg) (*AlertsPanel, tea.Cmd) <span class="cov8" title="1">{
        if !a.visible </span><span class="cov0" title="0">{
                return a, nil
        }</span>

        <span class="cov8" title="1">keyMsg, ok := msg.(tea.KeyMsg)
        if !ok </span><span class="cov0" title="0">{
                return a, nil
        }</span>

        // Close on Esc or H
        <span class="cov8" title="1">switch keyMsg.String() </span>{
        case "esc", "H":<span class="cov8" title="1">
                a.visible = false</span>
        }

        <span class="cov8" title="1">return a, nil</span>
}

// View renders the alerts panel.
func (a *AlertsPanel) View() string <span class="cov8" title="1">{
        if !a.visible </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">content := ""

        // Title
        titleStyle := lipgloss.NewStyle().
                Width(76).
                Align(lipgloss.Center).
                Bold(true).
                Foreground(a.styles.theme.Primary)
        content += titleStyle.Render("ALERTS") + "\n\n"

        // Get recent alerts (limit to fit modal height)
        alerts := a.alerts.Recent(18) // Reduced from 20 to fit better
        if len(alerts) == 0 </span><span class="cov8" title="1">{
                emptyStyle := lipgloss.NewStyle().
                        Width(76).
                        Align(lipgloss.Center).
                        Foreground(a.styles.theme.Muted)
                content += emptyStyle.Render("No alerts yet") + "\n"
        }</span> else<span class="cov0" title="0"> {
                // Render alerts (newest first)
                for _, alert := range alerts </span><span class="cov0" title="0">{
                        content += a.renderAlert(alert) + "\n"
                }</span>
        }

        <span class="cov8" title="1">content += "\n"

        // Footer
        footerText := "[Esc] or [H] to close"
        footerStyle := lipgloss.NewStyle().
                Width(76).
                Align(lipgloss.Center)
        content += footerStyle.Render(footerText)

        // Fixed size modal box (80 cols x 28 rows)
        modalStyle := a.styles.ModalBorder.
                Width(80).
                Height(28).
                Padding(1, 2)

        return modalStyle.Render(content)</span>
}

// renderAlert renders a single alert line.
func (a *AlertsPanel) renderAlert(alert Alert) string <span class="cov0" title="0">{
        // Timestamp
        timestamp := alert.Timestamp.Format("15:04:05")
        timeStyle := lipgloss.NewStyle().Foreground(a.styles.theme.Muted)

        // Alert type badge
        var badge string
        var badgeStyle lipgloss.Style

        switch alert.Type </span>{
        case AlertServiceCrashed:<span class="cov0" title="0">
                badgeStyle = lipgloss.NewStyle().
                        Foreground(a.styles.theme.Error).
                        Bold(true)
                badge = "[CRASH]"</span>
        case AlertServiceRecovered:<span class="cov0" title="0">
                badgeStyle = lipgloss.NewStyle().
                        Foreground(a.styles.theme.Success).
                        Bold(true)
                badge = "[RECOVER]"</span>
        case AlertProjectStarted:<span class="cov0" title="0">
                badgeStyle = lipgloss.NewStyle().
                        Foreground(a.styles.theme.Success).
                        Bold(true)
                badge = "[START]"</span>
        case AlertProjectStopped:<span class="cov0" title="0">
                badgeStyle = lipgloss.NewStyle().
                        Foreground(a.styles.theme.Warning).
                        Bold(true)
                badge = "[STOP]"</span>
        case AlertCritical:<span class="cov0" title="0">
                badgeStyle = lipgloss.NewStyle().
                        Foreground(a.styles.theme.Error).
                        Bold(true)
                badge = "[CRITICAL]"</span>
        case AlertInfo:<span class="cov0" title="0">
                badgeStyle = lipgloss.NewStyle().
                        Foreground(a.styles.theme.Primary).
                        Bold(true)
                badge = "[INFO]"</span>
        default:<span class="cov0" title="0">
                badgeStyle = lipgloss.NewStyle().
                        Foreground(a.styles.theme.Muted).
                        Bold(true)
                badge = "[UNKNOWN]"</span>
        }

        // Message (truncate if too long)
        <span class="cov0" title="0">message := alert.Message
        if alert.Service != "" </span><span class="cov0" title="0">{
                message = fmt.Sprintf("%s: %s", alert.Service, message)
        }</span>

        // Calculate max message length: 76 - timestamp(8) - badge(~10) - spacing(4) = ~54
        <span class="cov0" title="0">maxLen := 54
        if len(message) &gt; maxLen </span><span class="cov0" title="0">{
                message = message[:maxLen-3] + "..."
        }</span>

        // Build line: [timestamp] [badge] message
        <span class="cov0" title="0">line := timeStyle.Render(timestamp) + " " +
                badgeStyle.Render(badge) + " " +
                message

        lineStyle := lipgloss.NewStyle().Width(76)
        return lineStyle.Render(line)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package ui

import (
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// ConfirmDialog is a small confirmation dialog.
type ConfirmDialog struct {
        visible  bool
        message  string
        onYes    func() tea.Msg
        onNo     func() tea.Msg
        selected int // 0 = Yes, 1 = No
        styles   *Styles
}

// NewConfirmDialog creates a new confirmation dialog.
func NewConfirmDialog(styles *Styles) *ConfirmDialog <span class="cov8" title="1">{
        return &amp;ConfirmDialog{
                styles:   styles,
                selected: 1, // Default to "No" for safety
        }
}</span>

// Show displays the confirmation dialog.
func (c *ConfirmDialog) Show(message string, onYes, onNo func() tea.Msg) <span class="cov8" title="1">{
        c.visible = true
        c.message = message
        c.onYes = onYes
        c.onNo = onNo
        c.selected = 1 // Always default to No
}</span>

// Hide closes the dialog.
func (c *ConfirmDialog) Hide() <span class="cov8" title="1">{
        c.visible = false
}</span>

// IsVisible returns whether the dialog is shown.
func (c *ConfirmDialog) IsVisible() bool <span class="cov8" title="1">{
        return c.visible
}</span>

// Update handles input for the dialog.
func (c *ConfirmDialog) Update(msg tea.Msg) (*ConfirmDialog, tea.Cmd) <span class="cov8" title="1">{
        if !c.visible </span><span class="cov0" title="0">{
                return c, nil
        }</span>

        <span class="cov8" title="1">keyMsg, ok := msg.(tea.KeyMsg)
        if !ok </span><span class="cov0" title="0">{
                return c, nil
        }</span>

        <span class="cov8" title="1">switch keyMsg.String() </span>{
        case "left", "h", "right", "l", "tab":<span class="cov8" title="1">
                // Toggle between Yes and No
                c.selected = 1 - c.selected</span>

        case "enter":<span class="cov8" title="1">
                c.visible = false
                if c.selected == 0 &amp;&amp; c.onYes != nil </span><span class="cov8" title="1">{
                        return c, func() tea.Msg </span><span class="cov0" title="0">{ return c.onYes() }</span>
                } else<span class="cov8" title="1"> if c.onNo != nil </span><span class="cov8" title="1">{
                        return c, func() tea.Msg </span><span class="cov0" title="0">{ return c.onNo() }</span>
                }

        case "esc":<span class="cov0" title="0">
                c.visible = false
                if c.onNo != nil </span><span class="cov0" title="0">{
                        return c, func() tea.Msg </span><span class="cov0" title="0">{ return c.onNo() }</span>
                }

        case "y":<span class="cov8" title="1">
                // Quick yes
                c.visible = false
                if c.onYes != nil </span><span class="cov8" title="1">{
                        return c, func() tea.Msg </span><span class="cov0" title="0">{ return c.onYes() }</span>
                }

        case "n":<span class="cov8" title="1">
                // Quick no
                c.visible = false
                if c.onNo != nil </span><span class="cov8" title="1">{
                        return c, func() tea.Msg </span><span class="cov0" title="0">{ return c.onNo() }</span>
                }
        }

        <span class="cov8" title="1">return c, nil</span>
}

// View renders the confirmation dialog as a small box.
func (c *ConfirmDialog) View() string <span class="cov8" title="1">{
        if !c.visible </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">var content string

        // Message
        msgStyle := lipgloss.NewStyle().
                Width(46).
                Align(lipgloss.Center).
                Bold(true)
        content += msgStyle.Render(c.message) + "\n\n"

        // Buttons
        yesButton := "[ Yes ]"
        noButton := "[ No ]"

        if c.selected == 0 </span><span class="cov0" title="0">{
                yesButton = c.styles.SelectedItem.Render(yesButton)
        }</span> else<span class="cov8" title="1"> {
                noButton = c.styles.SelectedItem.Render(noButton)
        }</span>

        <span class="cov8" title="1">buttonLine := lipgloss.JoinHorizontal(
                lipgloss.Center,
                yesButton,
                "    ",
                noButton,
        )

        buttonStyle := lipgloss.NewStyle().Width(46).Align(lipgloss.Center)
        content += buttonStyle.Render(buttonLine) + "\n"

        // Help text
        helpStyle := lipgloss.NewStyle().
                Width(46).
                Align(lipgloss.Center).
                Foreground(c.styles.theme.Muted)
        content += "\n" + helpStyle.Render("←/→ or Tab to switch  [Enter] Confirm  [Esc] Cancel")

        // Wrap in a box (50 wide x 10 tall)
        boxStyle := c.styles.ModalBorder.
                Width(50).
                Height(10).
                Padding(1, 2)

        return boxStyle.Render(content)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package ui

import (
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
)

// HelpPanel manages the help modal.
type HelpPanel struct {
        styles  *Styles
        visible bool
        width   int
        height  int
}

// NewHelpPanel creates a help panel.
func NewHelpPanel(styles *Styles, width, height int) *HelpPanel <span class="cov8" title="1">{
        return &amp;HelpPanel{
                styles:  styles,
                visible: false,
                width:   width,
                height:  height,
        }
}</span>

// Show makes the help panel visible.
func (h *HelpPanel) Show() <span class="cov8" title="1">{
        h.visible = true
}</span>

// Hide closes the help panel.
func (h *HelpPanel) Hide() <span class="cov8" title="1">{
        h.visible = false
}</span>

// IsVisible returns whether the panel is shown.
func (h *HelpPanel) IsVisible() bool <span class="cov8" title="1">{
        return h.visible
}</span>

// SetSize updates the panel dimensions.
func (h *HelpPanel) SetSize(width, height int) <span class="cov8" title="1">{
        h.width = width
        h.height = height
}</span>

// Update handles input for the help panel.
func (h *HelpPanel) Update(msg tea.Msg) (*HelpPanel, tea.Cmd) <span class="cov8" title="1">{
        if !h.visible </span><span class="cov0" title="0">{
                return h, nil
        }</span>

        <span class="cov8" title="1">keyMsg, ok := msg.(tea.KeyMsg)
        if !ok </span><span class="cov0" title="0">{
                return h, nil
        }</span>

        // Close on Esc or ?
        <span class="cov8" title="1">switch keyMsg.String() </span>{
        case "esc", "?":<span class="cov8" title="1">
                h.visible = false</span>
        }

        <span class="cov8" title="1">return h, nil</span>
}

// View renders the help panel.
func (h *HelpPanel) View() string <span class="cov8" title="1">{
        if !h.visible </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Helper to highlight keybinds in brackets
        <span class="cov8" title="1">kb := func(key string) string </span><span class="cov8" title="1">{
                bracketStyle := lipgloss.NewStyle().Foreground(h.styles.theme.Muted)
                accentStyle := lipgloss.NewStyle().
                        Foreground(h.styles.theme.Primary).
                        Bold(true)
                return bracketStyle.Render("[") +
                        accentStyle.Render(key) +
                        bracketStyle.Render("]")
        }</span>

        // Non-bracketed keybind (for plain keys)
        <span class="cov8" title="1">k := func(key string) string </span><span class="cov8" title="1">{
                return lipgloss.NewStyle().
                        Foreground(h.styles.theme.Primary).
                        Bold(true).
                        Render(key)
        }</span>

        <span class="cov8" title="1">content := ""

        // Title
        titleStyle := lipgloss.NewStyle().
                Width(76).
                Align(lipgloss.Center).
                Bold(true).
                Foreground(h.styles.theme.Primary)
        content += titleStyle.Render("KEYBINDINGS") + "\n\n"

        // Two-column layout
        leftCol := ""
        rightCol := ""

        // GLOBAL
        leftCol += h.styles.Title.Render("GLOBAL") + "\n"
        leftCol += "  " + k("q") + "       Quit (detach)\n"
        leftCol += "  " + k("Ctrl+X") + "  Shutdown all\n"
        leftCol += "  " + k("S") + "       Settings\n"
        leftCol += "  " + k("E") + "       Edit config\n"
        leftCol += "  " + k("H") + "       Alerts\n"
        leftCol += "  " + k("?") + "       This help\n\n"

        // NAVIGATION
        rightCol += h.styles.Title.Render("NAVIGATION") + "\n"
        rightCol += "  " + kb("↑/k") + "     Up\n"
        rightCol += "  " + kb("↓/j") + "     Down\n"
        rightCol += "  " + kb("Tab") + "     Switch pane\n"
        rightCol += "  " + k("p") + "       Toggle packages/services\n"
        rightCol += "  " + kb("Enter") + "   Select/Confirm\n"
        rightCol += "  " + kb("Esc") + "     Back/Cancel\n\n"

        // SIDEBAR
        leftCol += h.styles.Title.Render("SIDEBAR") + "\n"
        leftCol += "  " + k("s") + "       Start project\n"
        leftCol += "  " + k("x") + "       Stop project\n"
        leftCol += "  " + k("d") + "       Delete project\n"
        leftCol += "  " + k("c") + "       Repair stale\n"
        leftCol += "  " + k("Ctrl+h") + "  Hide/show\n\n"

        // SERVICES
        rightCol += h.styles.Title.Render("SERVICES") + "\n"
        rightCol += "  " + k("s") + "       Start service\n"
        rightCol += "  " + k("x") + "       Stop service\n"
        rightCol += "  " + k("r") + "       Restart service\n"
        rightCol += "  " + kb("Enter") + "   Filter logs\n\n\n"

        // LOGS
        leftCol += h.styles.Title.Render("LOGS") + "\n"
        leftCol += "  " + k("f") + "       Toggle follow\n"
        leftCol += "  " + kb("↑/↓") + "     Scroll\n"
        leftCol += "  " + kb("g/G") + "     Top/Bottom\n"

        // SEARCH
        rightCol += h.styles.Title.Render("SEARCH (in Logs)") + "\n"
        rightCol += "  " + k("/") + "       Start search\n"
        rightCol += "  " + k("n") + "       Next match\n"
        rightCol += "  " + k("N") + "       Prev match\n"
        rightCol += "  " + k("Ctrl+f") + "  Filter mode\n"
        rightCol += "  " + kb("Esc") + "     Clear search\n"

        // Combine columns
        columns := lipgloss.JoinHorizontal(
                lipgloss.Top,
                leftCol,
                rightCol,
        )

        content += columns + "\n\n"

        // Footer
        footerText := kb("Esc") + " or " + kb("?") + " to close"
        footerStyle := lipgloss.NewStyle().
                Width(76).
                Align(lipgloss.Center)
        content += footerStyle.Render(footerText)

        // Fixed size modal box (80 cols x 28 rows)
        modalStyle := h.styles.ModalBorder.
                Width(80).
                Height(28).
                Padding(1, 2)

        return modalStyle.Render(content)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package ui

import "github.com/charmbracelet/bubbles/key"

// KeyMap defines all keybindings.
type KeyMap struct {
        // Global
        Quit       key.Binding
        Shutdown   key.Binding
        Settings   key.Binding
        EditConfig key.Binding
        Help       key.Binding
        Refresh    key.Binding
        History    key.Binding

        // Navigation
        Up     key.Binding
        Down   key.Binding
        Left     key.Binding
        Right    key.Binding
        Tab      key.Binding
        ShiftTab key.Binding
        Select   key.Binding
        Back     key.Binding

        // Actions
        Start   key.Binding
        Stop    key.Binding
        Restart key.Binding
        Search  key.Binding

        // Project Management
        Hide   key.Binding
        Delete key.Binding
        Edit   key.Binding
        Move   key.Binding
        Repair key.Binding

        // Logs
        Follow    key.Binding
        Filter    key.Binding
        Wrap      key.Binding
        Yank      key.Binding
        Top       key.Binding
        Bottom    key.Binding
        NextMatch key.Binding
        PrevMatch key.Binding
}

// DefaultKeyMap returns the default keybindings.
func DefaultKeyMap() KeyMap <span class="cov8" title="1">{
        return KeyMap{
                // Global
                Quit: key.NewBinding(
                        key.WithKeys("q"),
                        key.WithHelp("q", "quit"),
                ),
                Shutdown: key.NewBinding(
                        key.WithKeys("ctrl+x"),
                        key.WithHelp("ctrl+x", "shutdown all"),
                ),
                Settings: key.NewBinding(
                        key.WithKeys("S"),
                        key.WithHelp("S", "settings"),
                ),
                EditConfig: key.NewBinding(
                        key.WithKeys("E"),
                        key.WithHelp("E", "edit config"),
                ),
                Help: key.NewBinding(
                        key.WithKeys("?"),
                        key.WithHelp("?", "help"),
                ),
                Refresh: key.NewBinding(
                        key.WithKeys("R"),
                        key.WithHelp("R", "refresh"),
                ),
                History: key.NewBinding(
                        key.WithKeys("H"),
                        key.WithHelp("H", "alerts"),
                ),

                // Navigation
                Up: key.NewBinding(
                        key.WithKeys("k", "up"),
                        key.WithHelp("↑/k", "up"),
                ),
                Down: key.NewBinding(
                        key.WithKeys("j", "down"),
                        key.WithHelp("↓/j", "down"),
                ),
                Left: key.NewBinding(
                        key.WithKeys("h", "left"),
                        key.WithHelp("←/h", "left"),
                ),
                Right: key.NewBinding(
                        key.WithKeys("l", "right"),
                        key.WithHelp("→/l", "right"),
                ),
                Tab: key.NewBinding(
                        key.WithKeys("tab"),
                        key.WithHelp("tab", "next pane"),
                ),
                ShiftTab: key.NewBinding(
                        key.WithKeys("shift+tab"),
                        key.WithHelp("shift+tab", "prev pane"),
                ),
                Select: key.NewBinding(
                        key.WithKeys("enter"),
                        key.WithHelp("enter", "select"),
                ),
                Back: key.NewBinding(
                        key.WithKeys("esc"),
                        key.WithHelp("esc", "back"),
                ),

                // Actions
                Start: key.NewBinding(
                        key.WithKeys("s"),
                        key.WithHelp("s", "start"),
                ),
                Stop: key.NewBinding(
                        key.WithKeys("x"),
                        key.WithHelp("x", "stop"),
                ),
                Restart: key.NewBinding(
                        key.WithKeys("r"),
                        key.WithHelp("r", "restart"),
                ),
                Search: key.NewBinding(
                        key.WithKeys("/"),
                        key.WithHelp("/", "search"),
                ),

                // Project Management
                Hide: key.NewBinding(
                        key.WithKeys("ctrl+h"),
                        key.WithHelp("ctrl+h", "hide/show"),
                ),
                Delete: key.NewBinding(
                        key.WithKeys("d"),
                        key.WithHelp("d", "delete"),
                ),
                Edit: key.NewBinding(
                        key.WithKeys("e"),
                        key.WithHelp("e", "rename"),
                ),
                Move: key.NewBinding(
                        key.WithKeys("m"),
                        key.WithHelp("m", "relocate"),
                ),
                Repair: key.NewBinding(
                        key.WithKeys("c"),
                        key.WithHelp("c", "repair stale"),
                ),

                // Logs
                Follow: key.NewBinding(
                        key.WithKeys("f"),
                        key.WithHelp("f", "follow"),
                ),
                Filter: key.NewBinding(
                        key.WithKeys("ctrl+f"),
                        key.WithHelp("ctrl+f", "filter"),
                ),
                Wrap: key.NewBinding(
                        key.WithKeys("w"),
                        key.WithHelp("w", "wrap"),
                ),
                Yank: key.NewBinding(
                        key.WithKeys("y"),
                        key.WithHelp("y", "yank"),
                ),
                Top: key.NewBinding(
                        key.WithKeys("g"),
                        key.WithHelp("g", "top"),
                ),
                Bottom: key.NewBinding(
                        key.WithKeys("G"),
                        key.WithHelp("G", "bottom"),
                ),
                NextMatch: key.NewBinding(
                        key.WithKeys("n"),
                        key.WithHelp("n", "next match"),
                ),
                PrevMatch: key.NewBinding(
                        key.WithKeys("N"),
                        key.WithHelp("N", "prev match"),
                ),
        }
}</span>

// ShortHelp returns the short help bindings.
func (k KeyMap) ShortHelp() []key.Binding <span class="cov8" title="1">{
        return []key.Binding{k.Up, k.Down, k.Select, k.Start, k.Stop, k.Help, k.Quit}
}</span>

// FullHelp returns the full help bindings grouped by category.
func (k KeyMap) FullHelp() [][]key.Binding <span class="cov8" title="1">{
        return [][]key.Binding{
                {k.Up, k.Down, k.Tab, k.Select, k.Back},
                {k.Start, k.Stop, k.Restart, k.Search},
                {k.Follow, k.Top, k.Bottom, k.Wrap, k.NextMatch, k.PrevMatch},
                {k.Settings, k.History, k.Help, k.Quit},
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package ui

import (
        "regexp"
        "strings"
        "sync"
        "time"
)

// Common timestamp formats to try when parsing log lines
var timestampFormats = []string{
        // ISO formats
        "2006-01-02T15:04:05.000Z",
        "2006-01-02T15:04:05Z",
        "2006-01-02T15:04:05",
        "2006-01-02 15:04:05.000",
        "2006-01-02 15:04:05",
        // Date with timezone
        "Mon Jan 2 03:04:05 PM MST 2006",
        "Mon Jan 02 03:04:05 PM MST 2006",
        "Jan 2 15:04:05 2006",
        "Jan 02 15:04:05 2006",
        // Time only (assume today)
        "15:04:05.000",
        "15:04:05",
        "03:04:05 PM",
}

// Regex patterns to find timestamps in log lines
var timestampPatterns = []*regexp.Regexp{
        // ISO: 2006-01-02T15:04:05 or 2006-01-02 15:04:05
        regexp.MustCompile(`\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:?\d{2})?`),
        // Date: Mon Jan 2 03:04:05 PM MST 2006
        regexp.MustCompile(`(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)\s+(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s+\d{1,2}\s+\d{1,2}:\d{2}:\d{2}\s+(?:AM|PM)\s+\w+\s+\d{4}`),
        // Time only: 15:04:05
        regexp.MustCompile(`\b\d{2}:\d{2}:\d{2}(?:\.\d+)?\b`),
}

// ParseLogTimestamp attempts to extract a timestamp from a log line.
// Returns the parsed time and true if successful, or zero time and false if not found.
func ParseLogTimestamp(line string) (time.Time, bool) <span class="cov8" title="1">{
        for _, pattern := range timestampPatterns </span><span class="cov8" title="1">{
                match := pattern.FindString(line)
                if match == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">for _, format := range timestampFormats </span><span class="cov8" title="1">{
                        if t, err := time.Parse(format, match); err == nil </span><span class="cov8" title="1">{
                                // For time-only formats, use today's date
                                if t.Year() == 0 </span><span class="cov0" title="0">{
                                        now := time.Now()
                                        t = time.Date(now.Year(), now.Month(), now.Day(),
                                                t.Hour(), t.Minute(), t.Second(), t.Nanosecond(), now.Location())
                                }</span>
                                <span class="cov8" title="1">return t, true</span>
                        }
                }
        }

        <span class="cov8" title="1">return time.Time{}, false</span>
}

// LogLevel represents the severity of a log entry.
type LogLevel int

const (
        LevelDebug LogLevel = iota
        LevelInfo
        LevelWarn
        LevelError
)

func (l LogLevel) String() string <span class="cov8" title="1">{
        switch l </span>{
        case LevelDebug:<span class="cov0" title="0">
                return "debug"</span>
        case LevelInfo:<span class="cov8" title="1">
                return "info"</span>
        case LevelWarn:<span class="cov8" title="1">
                return "warn"</span>
        case LevelError:<span class="cov8" title="1">
                return "error"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// Log level detection patterns (case-insensitive keywords)
var levelPatterns = map[LogLevel][]string{
        LevelError: {"error", "err", "fatal", "critical", "panic", "exception", "fail"},
        LevelWarn:  {"warn", "warning", "caution"},
        LevelDebug: {"debug", "trace", "verbose"},
        LevelInfo:  {"info", "notice"},
}

// DetectLogLevel attempts to detect the log level from a message.
// Returns LevelInfo if no level can be detected.
func DetectLogLevel(message string) LogLevel <span class="cov8" title="1">{
        msgLower := strings.ToLower(message)

        // Check for explicit level indicators like [ERROR], ERROR:, level=error
        // Priority: Error &gt; Warn &gt; Debug &gt; Info

        // Check error first (highest priority)
        for _, pattern := range levelPatterns[LevelError] </span><span class="cov8" title="1">{
                if strings.Contains(msgLower, pattern) </span><span class="cov8" title="1">{
                        return LevelError
                }</span>
        }

        // Check warn
        <span class="cov8" title="1">for _, pattern := range levelPatterns[LevelWarn] </span><span class="cov8" title="1">{
                if strings.Contains(msgLower, pattern) </span><span class="cov8" title="1">{
                        return LevelWarn
                }</span>
        }

        // Check debug
        <span class="cov8" title="1">for _, pattern := range levelPatterns[LevelDebug] </span><span class="cov8" title="1">{
                if strings.Contains(msgLower, pattern) </span><span class="cov8" title="1">{
                        return LevelDebug
                }</span>
        }

        // Default to info
        <span class="cov8" title="1">return LevelInfo</span>
}

// LogEntry represents a single log line.
type LogEntry struct {
        Timestamp time.Time
        Service   string
        Level     LogLevel
        Message   string
}

// LogBuffer is a circular buffer for log entries.
type LogBuffer struct {
        entries  []LogEntry
        capacity int
        head     int
        size     int
        mu       sync.RWMutex
}

// NewLogBuffer creates a new log buffer with the given capacity.
func NewLogBuffer(capacity int) *LogBuffer <span class="cov8" title="1">{
        return &amp;LogBuffer{
                entries:  make([]LogEntry, capacity),
                capacity: capacity,
        }
}</span>

// Add appends a log entry to the buffer.
func (b *LogBuffer) Add(entry LogEntry) <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()

        b.entries[b.head] = entry
        b.head = (b.head + 1) % b.capacity
        if b.size &lt; b.capacity </span><span class="cov8" title="1">{
                b.size++
        }</span>
}

// Lines returns all log entries in order (oldest first).
func (b *LogBuffer) Lines() []LogEntry <span class="cov8" title="1">{
        b.mu.RLock()
        defer b.mu.RUnlock()

        result := make([]LogEntry, b.size)
        if b.size == 0 </span><span class="cov8" title="1">{
                return result
        }</span>

        <span class="cov8" title="1">start := 0
        if b.size == b.capacity </span><span class="cov8" title="1">{
                start = b.head
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; b.size; i++ </span><span class="cov8" title="1">{
                idx := (start + i) % b.capacity
                result[i] = b.entries[idx]
        }</span>

        <span class="cov8" title="1">return result</span>
}

// Tail returns the last n entries.
func (b *LogBuffer) Tail(n int) []LogEntry <span class="cov8" title="1">{
        b.mu.RLock()
        defer b.mu.RUnlock()

        if n &gt; b.size </span><span class="cov0" title="0">{
                n = b.size
        }</span>
        <span class="cov8" title="1">if n == 0 </span><span class="cov0" title="0">{
                return []LogEntry{}
        }</span>

        <span class="cov8" title="1">result := make([]LogEntry, n)
        start := (b.head - n + b.capacity) % b.capacity
        if b.size &lt; b.capacity </span><span class="cov8" title="1">{
                start = b.size - n
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                idx := (start + i) % b.capacity
                if b.size &lt; b.capacity </span><span class="cov8" title="1">{
                        idx = start + i
                }</span>
                <span class="cov8" title="1">result[i] = b.entries[idx]</span>
        }

        <span class="cov8" title="1">return result</span>
}

// Len returns the number of entries in the buffer.
func (b *LogBuffer) Len() int <span class="cov8" title="1">{
        b.mu.RLock()
        defer b.mu.RUnlock()
        return b.size
}</span>

// Clear removes all entries from the buffer.
func (b *LogBuffer) Clear() <span class="cov8" title="1">{
        b.mu.Lock()
        defer b.mu.Unlock()
        b.head = 0
        b.size = 0
}</span>

// Capacity returns the maximum capacity of the buffer.
func (b *LogBuffer) Capacity() int <span class="cov8" title="1">{
        return b.capacity
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package ui

import (
        "sort"
        "sync"
        "time"
)

// LogInterleaver collects log entries from multiple sources,
// sorts them by timestamp, and outputs to a unified buffer.
type LogInterleaver struct {
        buffer    []LogEntry
        output    *LogBuffer
        flushTick *time.Ticker
        mu        sync.Mutex
        done      chan struct{}
        wg        sync.WaitGroup
        started   bool
}

// NewLogInterleaver creates an interleaver that outputs to the given buffer.
func NewLogInterleaver(output *LogBuffer) *LogInterleaver <span class="cov8" title="1">{
        return &amp;LogInterleaver{
                buffer: make([]LogEntry, 0, 100),
                output: output,
                done:   make(chan struct{}),
        }
}</span>

// Add queues an entry for interleaving.
func (li *LogInterleaver) Add(entry LogEntry) <span class="cov8" title="1">{
        li.mu.Lock()
        defer li.mu.Unlock()
        li.buffer = append(li.buffer, entry)
}</span>

// Start begins the background flush goroutine.
func (li *LogInterleaver) Start() <span class="cov8" title="1">{
        li.mu.Lock()
        if li.started </span><span class="cov0" title="0">{
                li.mu.Unlock()
                return
        }</span>
        <span class="cov8" title="1">li.started = true
        li.mu.Unlock()

        li.flushTick = time.NewTicker(50 * time.Millisecond)
        li.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer li.wg.Done()
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-li.flushTick.C:<span class="cov8" title="1">
                                li.flush()</span>
                        case &lt;-li.done:<span class="cov8" title="1">
                                li.flushTick.Stop()
                                li.flush() // Final flush
                                return</span>
                        }
                }
        }()
}

// Stop halts the background goroutine.
func (li *LogInterleaver) Stop() <span class="cov8" title="1">{
        li.mu.Lock()
        if !li.started </span><span class="cov0" title="0">{
                li.mu.Unlock()
                return
        }</span>
        <span class="cov8" title="1">li.mu.Unlock()

        close(li.done)
        li.wg.Wait()</span>
}

// flush sorts pending entries by timestamp and writes to output.
func (li *LogInterleaver) flush() <span class="cov8" title="1">{
        li.mu.Lock()
        if len(li.buffer) == 0 </span><span class="cov8" title="1">{
                li.mu.Unlock()
                return
        }</span>

        // Sort by timestamp
        <span class="cov8" title="1">sort.Slice(li.buffer, func(i, j int) bool </span><span class="cov8" title="1">{
                return li.buffer[i].Timestamp.Before(li.buffer[j].Timestamp)
        }</span>)

        // Copy entries to output
        <span class="cov8" title="1">entries := li.buffer
        li.buffer = make([]LogEntry, 0, 100)
        li.mu.Unlock()

        // Add to output buffer (outside lock to avoid potential deadlock)
        for _, e := range entries </span><span class="cov8" title="1">{
                li.output.Add(e)
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package ui

import (
        "fmt"
        "strings"

        "github.com/charmbracelet/lipgloss"
)

// LogView renders log entries with formatting and scroll support.
type LogView struct {
        buffer  *LogBuffer
        styles  *Styles
        width   int
        height  int
        offset  int    // Scroll offset from bottom
        follow  bool   // Auto-scroll to bottom
        service string // Filter to specific service, empty = all
        // Search fields
        searchQuery  string
        searchActive bool
        filterMode   bool  // Only show matching lines
        matches      []int // Line indices that match
        matchIndex   int   // Current match cursor (0-indexed internally)
}

// NewLogView creates a new log view component.
func NewLogView(styles *Styles, width, height int) *LogView <span class="cov8" title="1">{
        return &amp;LogView{
                buffer: NewLogBuffer(10000),
                styles: styles,
                width:  width,
                height: height,
                follow: true,
        }
}</span>

// AddEntry adds a log entry to the view.
func (lv *LogView) AddEntry(entry LogEntry) <span class="cov8" title="1">{
        lv.buffer.Add(entry)
        if lv.follow </span><span class="cov8" title="1">{
                lv.offset = 0
        }</span>
}

// SetBuffer replaces the internal buffer (for unified view).
func (lv *LogView) SetBuffer(buf *LogBuffer) <span class="cov8" title="1">{
        lv.buffer = buf
}</span>

// SetService filters logs to a specific service (empty = all).
func (lv *LogView) SetService(service string) <span class="cov8" title="1">{
        lv.service = service
        lv.offset = 0
}</span>

// GetService returns the current service filter.
func (lv *LogView) GetService() string <span class="cov8" title="1">{
        return lv.service
}</span>

// ScrollInfo returns current scroll position info (current line, total lines).
func (lv *LogView) ScrollInfo() (int, int) <span class="cov8" title="1">{
        all := lv.buffer.Lines()

        // Apply service filter
        if lv.service != "" </span><span class="cov0" title="0">{
                filtered := make([]LogEntry, 0)
                for _, e := range all </span><span class="cov0" title="0">{
                        if e.Service == lv.service </span><span class="cov0" title="0">{
                                filtered = append(filtered, e)
                        }</span>
                }
                <span class="cov0" title="0">all = filtered</span>
        }

        <span class="cov8" title="1">total := len(all)
        if total == 0 </span><span class="cov8" title="1">{
                return 0, 0
        }</span>

        // Current position (from bottom, inverted for display)
        <span class="cov0" title="0">currentLine := total - lv.offset
        if currentLine &gt; total </span><span class="cov0" title="0">{
                currentLine = total
        }</span>
        <span class="cov0" title="0">if currentLine &lt; 1 </span><span class="cov0" title="0">{
                currentLine = 1
        }</span>

        <span class="cov0" title="0">return currentLine, total</span>
}

// SetSize updates the viewport dimensions.
func (lv *LogView) SetSize(width, height int) <span class="cov8" title="1">{
        lv.width = width
        lv.height = height
}</span>

// View renders the log viewport.
func (lv *LogView) View() string <span class="cov8" title="1">{
        lines := lv.getVisibleLines()

        var sb strings.Builder
        for _, entry := range lines </span><span class="cov8" title="1">{
                sb.WriteString(lv.formatEntry(entry))
                sb.WriteString("\n")
        }</span>

        // Pad to fill height
        <span class="cov8" title="1">lineCount := len(lines)
        for i := lineCount; i &lt; lv.height; i++ </span><span class="cov8" title="1">{
                sb.WriteString("\n")
        }</span>

        <span class="cov8" title="1">return sb.String()</span>
}

func (lv *LogView) getVisibleLines() []LogEntry <span class="cov8" title="1">{
        all := lv.buffer.Lines()

        // Filter by service if set
        if lv.service != "" </span><span class="cov0" title="0">{
                filtered := make([]LogEntry, 0)
                for _, e := range all </span><span class="cov0" title="0">{
                        if e.Service == lv.service </span><span class="cov0" title="0">{
                                filtered = append(filtered, e)
                        }</span>
                }
                <span class="cov0" title="0">all = filtered</span>
        }

        // Filter by search query if filter mode is active
        <span class="cov8" title="1">if lv.filterMode &amp;&amp; lv.searchActive &amp;&amp; lv.searchQuery != "" </span><span class="cov8" title="1">{
                queryLower := strings.ToLower(lv.searchQuery)
                filtered := make([]LogEntry, 0)
                for _, e := range all </span><span class="cov8" title="1">{
                        if strings.Contains(strings.ToLower(e.Message), queryLower) </span><span class="cov8" title="1">{
                                filtered = append(filtered, e)
                        }</span>
                }
                <span class="cov8" title="1">all = filtered</span>
        }

        <span class="cov8" title="1">total := len(all)
        if total == 0 </span><span class="cov8" title="1">{
                return []LogEntry{}
        }</span>

        // Calculate visible range
        <span class="cov8" title="1">visibleHeight := lv.height
        if visibleHeight &gt; total </span><span class="cov8" title="1">{
                visibleHeight = total
        }</span>

        <span class="cov8" title="1">end := total - lv.offset
        if end &gt; total </span><span class="cov0" title="0">{
                end = total
        }</span>
        <span class="cov8" title="1">start := end - visibleHeight
        if start &lt; 0 </span><span class="cov0" title="0">{
                start = 0
        }</span>

        <span class="cov8" title="1">return all[start:end]</span>
}

func (lv *LogView) formatEntry(entry LogEntry) string <span class="cov8" title="1">{
        // Timestamp (when we received the log)
        timestamp := lv.styles.LogTimestamp.Render(entry.Timestamp.Format("15:04:05"))

        // Strip existing service prefix from message (e.g., "[worker] ...")
        msg := entry.Message
        if entry.Service != "" </span><span class="cov8" title="1">{
                prefix := fmt.Sprintf("[%s] ", entry.Service)
                msg = strings.TrimPrefix(msg, prefix)
        }</span>

        // Format message with level colorization and search highlighting
        <span class="cov8" title="1">message := lv.formatMessageWithLevel(msg, entry.Level)

        // Add service prefix for unified view (colored tag)
        if lv.service == "" &amp;&amp; entry.Service != "" </span><span class="cov8" title="1">{
                serviceTag := lipgloss.NewStyle().
                        Foreground(lv.getServiceColor(entry.Service)).
                        Render(fmt.Sprintf("[%s]", strings.ToUpper(entry.Service)))
                return fmt.Sprintf("%s %s %s", timestamp, serviceTag, message)
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%s %s", timestamp, message)</span>
}

// getLevelStyle returns the style for a log level.
func (lv *LogView) getLevelStyle(level LogLevel) lipgloss.Style <span class="cov8" title="1">{
        switch level </span>{
        case LevelError:<span class="cov0" title="0">
                return lv.styles.LogLevelError</span>
        case LevelWarn:<span class="cov0" title="0">
                return lv.styles.LogLevelWarn</span>
        case LevelDebug:<span class="cov8" title="1">
                return lipgloss.NewStyle().Foreground(lipgloss.Color("#6272A4"))</span> // Muted blue/gray
        default:<span class="cov8" title="1">
                return lv.styles.LogLine</span>
        }
}

// formatMessageWithLevel formats a message with level colors and search highlighting.
func (lv *LogView) formatMessageWithLevel(msg string, level LogLevel) string <span class="cov8" title="1">{
        baseStyle := lv.getLevelStyle(level)

        if !lv.searchActive || lv.searchQuery == "" </span><span class="cov8" title="1">{
                return baseStyle.Render(msg)
        }</span>

        // Case-insensitive search for highlighting
        <span class="cov8" title="1">queryLower := strings.ToLower(lv.searchQuery)
        msgLower := strings.ToLower(msg)

        idx := strings.Index(msgLower, queryLower)
        if idx == -1 </span><span class="cov0" title="0">{
                return baseStyle.Render(msg)
        }</span>

        // Highlight style: bold with reverse video (background highlight)
        <span class="cov8" title="1">highlightStyle := lipgloss.NewStyle().
                Bold(true).
                Reverse(true)

        // Build highlighted message by finding all occurrences
        var result strings.Builder
        pos := 0
        for </span><span class="cov8" title="1">{
                idx = strings.Index(msgLower[pos:], queryLower)
                if idx == -1 </span><span class="cov8" title="1">{
                        // No more matches, append remaining text
                        result.WriteString(baseStyle.Render(msg[pos:]))
                        break</span>
                }
                // Append text before match
                <span class="cov8" title="1">if idx &gt; 0 </span><span class="cov0" title="0">{
                        result.WriteString(baseStyle.Render(msg[pos : pos+idx]))
                }</span>
                // Append highlighted match (using original case from msg)
                <span class="cov8" title="1">matchEnd := pos + idx + len(lv.searchQuery)
                result.WriteString(highlightStyle.Render(msg[pos+idx : matchEnd]))
                pos = matchEnd</span>
        }

        <span class="cov8" title="1">return result.String()</span>
}

// formatMessage formats a message with search highlighting if search is active.
func (lv *LogView) formatMessage(msg string) string <span class="cov0" title="0">{
        if !lv.searchActive || lv.searchQuery == "" </span><span class="cov0" title="0">{
                return lv.styles.LogLine.Render(msg)
        }</span>

        // Case-insensitive search for highlighting
        <span class="cov0" title="0">queryLower := strings.ToLower(lv.searchQuery)
        msgLower := strings.ToLower(msg)

        idx := strings.Index(msgLower, queryLower)
        if idx == -1 </span><span class="cov0" title="0">{
                return lv.styles.LogLine.Render(msg)
        }</span>

        // Highlight style: bold with reverse video (background highlight)
        <span class="cov0" title="0">highlightStyle := lipgloss.NewStyle().
                Bold(true).
                Reverse(true)

        // Build highlighted message by finding all occurrences
        var result strings.Builder
        pos := 0
        for </span><span class="cov0" title="0">{
                idx = strings.Index(msgLower[pos:], queryLower)
                if idx == -1 </span><span class="cov0" title="0">{
                        // No more matches, append remaining text
                        result.WriteString(lv.styles.LogLine.Render(msg[pos:]))
                        break</span>
                }
                // Append text before match
                <span class="cov0" title="0">if idx &gt; 0 </span><span class="cov0" title="0">{
                        result.WriteString(lv.styles.LogLine.Render(msg[pos : pos+idx]))
                }</span>
                // Append highlighted match (using original case from msg)
                <span class="cov0" title="0">matchEnd := pos + idx + len(lv.searchQuery)
                result.WriteString(highlightStyle.Render(msg[pos+idx : matchEnd]))
                pos = matchEnd</span>
        }

        <span class="cov0" title="0">return result.String()</span>
}

func (lv *LogView) getServiceColor(service string) lipgloss.Color <span class="cov8" title="1">{
        // Simple hash-based color assignment
        colors := []lipgloss.Color{
                "#336791", // postgres blue
                "#00D8FF", // cyan
                "#98C379", // green
                "#E06C75", // red
                "#C678DD", // purple
                "#E5C07B", // yellow
                "#56B6C2", // teal
        }

        hash := 0
        for _, c := range service </span><span class="cov8" title="1">{
                hash = hash*31 + int(c)
        }</span>
        <span class="cov8" title="1">if hash &lt; 0 </span><span class="cov0" title="0">{
                hash = -hash
        }</span>

        <span class="cov8" title="1">return colors[hash%len(colors)]</span>
}

// Scroll operations

func (lv *LogView) ScrollUp() <span class="cov8" title="1">{
        lv.follow = false
        maxOffset := lv.buffer.Len() - lv.height
        if maxOffset &lt; 0 </span><span class="cov0" title="0">{
                maxOffset = 0
        }</span>
        <span class="cov8" title="1">if lv.offset &lt; maxOffset </span><span class="cov8" title="1">{
                lv.offset++
        }</span>
}

func (lv *LogView) ScrollDown() <span class="cov8" title="1">{
        if lv.offset &gt; 0 </span><span class="cov8" title="1">{
                lv.offset--
        }</span>
        <span class="cov8" title="1">if lv.offset == 0 </span><span class="cov8" title="1">{
                lv.follow = true
        }</span>
}

func (lv *LogView) ScrollToTop() <span class="cov8" title="1">{
        lv.follow = false
        lv.offset = lv.buffer.Len() - lv.height
        if lv.offset &lt; 0 </span><span class="cov0" title="0">{
                lv.offset = 0
        }</span>
}

func (lv *LogView) ScrollToBottom() <span class="cov8" title="1">{
        lv.offset = 0
        lv.follow = true
}</span>

func (lv *LogView) PageUp() <span class="cov8" title="1">{
        lv.follow = false
        lv.offset += lv.height
        maxOffset := lv.buffer.Len() - lv.height
        if lv.offset &gt; maxOffset </span><span class="cov0" title="0">{
                lv.offset = maxOffset
        }</span>
        <span class="cov8" title="1">if lv.offset &lt; 0 </span><span class="cov0" title="0">{
                lv.offset = 0
        }</span>
}

func (lv *LogView) PageDown() <span class="cov8" title="1">{
        lv.offset -= lv.height
        if lv.offset &lt; 0 </span><span class="cov8" title="1">{
                lv.offset = 0
                lv.follow = true
        }</span>
}

// Follow mode

func (lv *LogView) ToggleFollow() <span class="cov8" title="1">{
        lv.follow = !lv.follow
        if lv.follow </span><span class="cov0" title="0">{
                lv.offset = 0
        }</span>
}

func (lv *LogView) SetFollow(f bool) <span class="cov8" title="1">{
        lv.follow = f
        if f </span><span class="cov0" title="0">{
                lv.offset = 0
        }</span>
}

func (lv *LogView) IsFollowing() bool <span class="cov8" title="1">{
        return lv.follow
}</span>

// Clear removes all log entries.
func (lv *LogView) Clear() <span class="cov8" title="1">{
        lv.buffer.Clear()
        lv.offset = 0
}</span>

// Search methods

// SetSearch sets the search query and finds all matches.
func (lv *LogView) SetSearch(query string) <span class="cov8" title="1">{
        lv.searchQuery = query
        lv.searchActive = query != ""
        lv.matches = nil
        lv.matchIndex = 0

        if !lv.searchActive </span><span class="cov0" title="0">{
                return
        }</span>

        // Find all matching line indices (case-insensitive)
        <span class="cov8" title="1">queryLower := strings.ToLower(query)
        all := lv.getFilteredLines()
        for i, entry := range all </span><span class="cov8" title="1">{
                if strings.Contains(strings.ToLower(entry.Message), queryLower) </span><span class="cov8" title="1">{
                        lv.matches = append(lv.matches, i)
                }</span>
        }

        // Jump to first match if found
        <span class="cov8" title="1">if len(lv.matches) &gt; 0 </span><span class="cov8" title="1">{
                lv.scrollToMatch(0)
        }</span>
}

// ClearSearch clears the search state.
func (lv *LogView) ClearSearch() <span class="cov8" title="1">{
        lv.searchQuery = ""
        lv.searchActive = false
        lv.filterMode = false
        lv.matches = nil
        lv.matchIndex = 0
}</span>

// NextMatch jumps to the next match.
func (lv *LogView) NextMatch() <span class="cov8" title="1">{
        if len(lv.matches) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">lv.matchIndex = (lv.matchIndex + 1) % len(lv.matches)
        lv.scrollToMatch(lv.matchIndex)</span>
}

// PrevMatch jumps to the previous match.
func (lv *LogView) PrevMatch() <span class="cov8" title="1">{
        if len(lv.matches) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">lv.matchIndex--
        if lv.matchIndex &lt; 0 </span><span class="cov8" title="1">{
                lv.matchIndex = len(lv.matches) - 1
        }</span>
        <span class="cov8" title="1">lv.scrollToMatch(lv.matchIndex)</span>
}

// ToggleFilter toggles filter mode (show only matching lines).
func (lv *LogView) ToggleFilter() <span class="cov8" title="1">{
        lv.filterMode = !lv.filterMode
        lv.offset = 0
}</span>

// IsSearchActive returns true if search is active.
func (lv *LogView) IsSearchActive() bool <span class="cov8" title="1">{
        return lv.searchActive
}</span>

// IsFilterMode returns true if filter mode is on.
func (lv *LogView) IsFilterMode() bool <span class="cov8" title="1">{
        return lv.filterMode
}</span>

// SearchQuery returns the current search query.
func (lv *LogView) SearchQuery() string <span class="cov8" title="1">{
        return lv.searchQuery
}</span>

// MatchCount returns the total number of matches.
func (lv *LogView) MatchCount() int <span class="cov8" title="1">{
        return len(lv.matches)
}</span>

// CurrentMatchIndex returns the current match position (1-indexed for display).
func (lv *LogView) CurrentMatchIndex() int <span class="cov8" title="1">{
        if len(lv.matches) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return lv.matchIndex + 1</span>
}

// scrollToMatch scrolls the view to make the match at the given index visible.
func (lv *LogView) scrollToMatch(idx int) <span class="cov8" title="1">{
        if idx &lt; 0 || idx &gt;= len(lv.matches) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">lineIdx := lv.matches[idx]
        total := len(lv.getFilteredLines())

        // Calculate offset to center the match in view
        // offset is distance from bottom, so offset = total - lineIdx - height/2
        lv.offset = total - lineIdx - lv.height/2
        if lv.offset &lt; 0 </span><span class="cov8" title="1">{
                lv.offset = 0
        }</span>
        <span class="cov8" title="1">maxOffset := total - lv.height
        if maxOffset &lt; 0 </span><span class="cov8" title="1">{
                maxOffset = 0
        }</span>
        <span class="cov8" title="1">if lv.offset &gt; maxOffset </span><span class="cov0" title="0">{
                lv.offset = maxOffset
        }</span>
        <span class="cov8" title="1">lv.follow = false</span>
}

// getFilteredLines returns lines filtered by service (but not by search filter mode).
func (lv *LogView) getFilteredLines() []LogEntry <span class="cov8" title="1">{
        all := lv.buffer.Lines()

        // Filter by service if set
        if lv.service != "" </span><span class="cov0" title="0">{
                filtered := make([]LogEntry, 0)
                for _, e := range all </span><span class="cov0" title="0">{
                        if e.Service == lv.service </span><span class="cov0" title="0">{
                                filtered = append(filtered, e)
                        }</span>
                }
                <span class="cov0" title="0">all = filtered</span>
        }

        <span class="cov8" title="1">return all</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package ui

import (
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "github.com/charmbracelet/bubbles/key"
        "github.com/charmbracelet/bubbles/list"
        "github.com/charmbracelet/bubbles/spinner"
        "github.com/charmbracelet/bubbles/table"
        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
        "github.com/lucasb-eyer/go-colorful"

        "github.com/infktd/devdash/internal/compose"
        "github.com/infktd/devdash/internal/config"
        "github.com/infktd/devdash/internal/health"
        "github.com/infktd/devdash/internal/notify"
        "github.com/infktd/devdash/internal/packages"
        "github.com/infktd/devdash/internal/registry"
)

// FocusedPane tracks which pane has focus.
type FocusedPane int

const (
        PaneSidebar FocusedPane = iota
        PaneServices
        PanePackages
        PaneLogs
)

// projectListItem implements list.Item for the project list.
type projectListItem struct {
        project *registry.Project
        state   registry.ProjectState
}

func (i projectListItem) FilterValue() string <span class="cov8" title="1">{
        return i.project.Name
}</span>

func (i projectListItem) Title() string <span class="cov0" title="0">{
        return i.project.Name
}</span>

func (i projectListItem) Description() string <span class="cov0" title="0">{
        return i.project.Path
}</span>

// sectionHeaderItem represents a section header in the project list.
type sectionHeaderItem struct {
        title string
}

func (i sectionHeaderItem) FilterValue() string <span class="cov0" title="0">{
        return "" // Headers don't participate in filtering
}</span>

func (i sectionHeaderItem) Title() string <span class="cov0" title="0">{
        return i.title
}</span>

func (i sectionHeaderItem) Description() string <span class="cov0" title="0">{
        return ""
}</span>

// Model is the main application model for devdash.
type Model struct {
        // Core data
        config   *config.Config
        registry *registry.Registry
        styles   *Styles
        keys     KeyMap

        // Dimensions
        width  int
        height int

        // Focus state
        focused         FocusedPane
        selectedProject int
        selectedService int

        // Overlay state
        showHelp     bool
        showSettings bool
        showSplash   bool
        showPackages bool // When true, show packages pane instead of services (narrow terminals)

        // Search state (for logs)
        searchMode         bool
        searchInput        textinput.Model
        followBeforeSearch bool // Track follow mode state before entering search

        // Project filter state (custom implementation)
        projectFilterMode  bool
        projectFilterInput string

        // Components
        logView       *LogView
        packagesView  *PackagesView
        toast         *ToastManager
        alerts        *AlertHistory
        alertsPanel   *AlertsPanel
        settings      *SettingsPanel
        helpPanel     *HelpPanel
        splash        *SplashScreen
        confirm       *ConfirmDialog
        health        *health.Monitor
        notifier      *notify.Notifier
        spinner       spinner.Model
        servicesTable table.Model
        projectsList  list.Model

        // Loading state
        loadingOp       string    // Description of current operation
        loadingProject  string    // Project being operated on
        loadingProgress float64   // Progress percentage (0.0 to 1.0)
        loadingStage    string    // Current stage description
        loadingStarted  time.Time // When operation started

        // Compose clients per project (keyed by project path)
        clients map[string]*compose.Client

        // Current project services
        services []compose.ProcessStatus

        // Displayed projects in sidebar order (active first, then idle)
        displayedProjects []*registry.Project

        // Cached project states (to avoid inconsistent state during rendering)
        projectStates map[string]registry.ProjectState

        // Track last seen log message per service to fetch only new logs
        lastLogMsg map[string]string

        // Track log activity timestamps per service for flow indicators
        logActivity   map[string]time.Time
        activityFrame int // Animation frame counter for log flow spinner

        // Track service states for detecting transitions
        serviceStates       map[string]string    // Last known state per service
        stateChangeTime     map[string]time.Time // When state last changed
        stateFlashIntensity map[string]float64   // Flash intensity (1.0 = bright, 0.0 = normal)

        // Track resource usage history for sparklines
        cpuHistory map[string][]float64 // Last 10 CPU readings per service
        memHistory map[string][]int64   // Last 10 memory readings per service
}

// Messages for async operations
type tickMsg time.Time
type activityTickMsg time.Time
type progressTickMsg time.Time
type pollServicesMsg struct{}
type servicesUpdatedMsg struct {
        services []compose.ProcessStatus
        err      error
}
type healthEventMsg health.Event
type logsUpdatedMsg struct {
        logsByService map[string][]string
        err           error
}
type projectStartedMsg struct {
        project string
        err     error
}
type projectStoppedMsg struct {
        project string
        err     error
}
type serviceOperationMsg struct {
        service   string
        operation string // "start", "stop", "restart"
        err       error
}
type projectDeletedMsg struct {
        project string
}
type projectHiddenMsg struct {
        project string
        hidden  bool
}
type projectRepairedMsg struct {
        project string
        err     error
}
type configEditedMsg struct {
        config *config.Config
        err    error
}

// New creates a new devdash model.
func New(cfg *config.Config, reg *registry.Registry) *Model <span class="cov8" title="1">{
        theme := GetTheme(cfg.UI.Theme)
        styles := NewStyles(theme)

        alertHistory := NewAlertHistory(100)

        // Initialize spinner
        s := spinner.New()
        s.Spinner = spinner.Dot
        s.Style = lipgloss.NewStyle().Foreground(theme.Primary)

        // Initialize search input
        ti := textinput.New()
        ti.Placeholder = ""
        ti.Prompt = "/"
        ti.PromptStyle = lipgloss.NewStyle().Foreground(theme.Primary)
        ti.TextStyle = lipgloss.NewStyle().Foreground(theme.Primary)
        ti.Cursor.Style = lipgloss.NewStyle().Foreground(theme.Primary)
        ti.CharLimit = 100

        // Initialize services table - proper widths for content
        columns := []table.Column{
                {Title: "STATUS", Width: 10},
                {Title: "SERVICE", Width: 12},  // Reduced from 18 to 12
                {Title: "PID", Width: 8},
                {Title: "CPU", Width: 7},
                {Title: "MEM", Width: 8},
                {Title: "UPTIME", Width: 10},
        }
        t := table.New(
                table.WithColumns(columns),
                table.WithFocused(false),
                table.WithHeight(10),
        )
        tableStyle := table.DefaultStyles()
        tableStyle.Header = tableStyle.Header.
                BorderStyle(lipgloss.NormalBorder()).
                BorderForeground(theme.Muted).
                BorderBottom(true).
                Bold(true).
                Foreground(theme.Primary)
        tableStyle.Selected = tableStyle.Selected.
                Foreground(theme.Primary).
                Bold(true)
        // Default cell padding (0, 1) works well
        t.SetStyles(tableStyle)

        // Initialize projects list with custom delegate (model set later to avoid circular reference)
        projectsDelegate := &amp;projectDelegate{styles: styles}
        projectsList := list.New([]list.Item{}, projectsDelegate, 30, 20)
        projectsList.Title = ""
        projectsList.SetShowStatusBar(false)  // Hide status bar (prevents "2items" counter from section headers)
        projectsList.SetFilteringEnabled(false)  // Disable built-in filter (we'll use custom)
        projectsList.SetShowHelp(false)

        // Apply theme colors directly to list styles and remove all padding
        projectsList.Styles.Title = lipgloss.NewStyle()  // Hide default title
        projectsList.Styles.PaginationStyle = lipgloss.NewStyle()
        projectsList.Styles.HelpStyle = lipgloss.NewStyle()
        // Remove any default top/bottom padding from the list
        projectsList.Styles.NoItems = lipgloss.NewStyle()

        m := &amp;Model{
                config:   cfg,
                registry: reg,
                styles:   styles,
                keys:     DefaultKeyMap(),
                focused:  PaneSidebar,

                // Initialize components
                logView:       NewLogView(styles, 80, 20),
                packagesView:  NewPackagesView(styles),
                toast:         NewToastManager(styles, 60),
                alerts:        alertHistory,
                alertsPanel:   NewAlertsPanel(styles, alertHistory, 80, 24),
                settings:      NewSettingsPanel(cfg, styles, 80, 24),
                helpPanel:     NewHelpPanel(styles, 80, 24),
                splash:        NewSplashScreen(styles, 80, 24),
                confirm:       NewConfirmDialog(styles),
                health:        health.NewMonitor(2 * time.Second),
                notifier:      notify.NewNotifier(cfg.Notifications.SystemEnabled),
                spinner:             s,
                searchInput:         ti,
                servicesTable:       t,
                projectsList:        projectsList,
                clients:             make(map[string]*compose.Client),
                lastLogMsg:          make(map[string]string),
                logActivity:         make(map[string]time.Time),
                projectStates:       make(map[string]registry.ProjectState),
                serviceStates:       make(map[string]string),
                stateChangeTime:     make(map[string]time.Time),
                stateFlashIntensity: make(map[string]float64),
                cpuHistory:          make(map[string][]float64),
                memHistory:          make(map[string][]int64),
        }

        // Show splash on startup
        m.showSplash = true
        m.splash.SetMessage("Starting devdash...")
        m.splash.SetProgress(0.0)

        // Set model reference on delegate (needed for spinner and loading state)
        projectsDelegate.model = m

        // Initialize displayed projects
        m.updateDisplayedProjects()

        return m
}</span>

// handleMouseEvent handles mouse events for focus following.
func (m *Model) handleMouseEvent(msg tea.MouseMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        // Only handle motion and wheel events for focus following
        if msg.Type != tea.MouseMotion &amp;&amp; msg.Type != tea.MouseWheelUp &amp;&amp; msg.Type != tea.MouseWheelDown </span><span class="cov0" title="0">{
                return m, nil
        }</span>

        // Skip if modals are open
        <span class="cov8" title="1">if m.showSplash || m.showSettings || m.showHelp || m.alertsPanel.IsVisible() || m.confirm.IsVisible() </span><span class="cov8" title="1">{
                return m, nil
        }</span>

        // Calculate pane boundaries
        <span class="cov8" title="1">sidebarWidth := m.config.UI.SidebarWidth
        bodyHeight := m.height - 4 // header + footer

        // Determine which pane the mouse is over
        x := msg.X
        y := msg.Y

        var newFocus FocusedPane

        if x &lt; sidebarWidth </span><span class="cov8" title="1">{
                // Mouse is in sidebar (projects)
                newFocus = PaneSidebar
        }</span> else<span class="cov8" title="1"> if m.shouldShowBothPanes() </span><span class="cov8" title="1">{
                // Wide terminal: Services, Packages, Logs stacked vertically
                servicesHeight := bodyHeight / 4
                packagesHeight := bodyHeight / 4

                if y &lt; servicesHeight+2 </span><span class="cov0" title="0">{ // +2 for header
                        newFocus = PaneServices
                }</span> else<span class="cov8" title="1"> if y &lt; servicesHeight+packagesHeight+4 </span><span class="cov8" title="1">{ // +4 for header and borders
                        newFocus = PanePackages
                }</span> else<span class="cov0" title="0"> {
                        newFocus = PaneLogs
                }</span>
        } else<span class="cov8" title="1"> {
                // Narrow terminal: either Services or Packages, plus Logs
                mainPaneHeight := bodyHeight / 3

                if y &lt; mainPaneHeight+2 </span><span class="cov8" title="1">{ // +2 for header
                        // In main pane area - could be services or packages
                        if m.showPackages </span><span class="cov0" title="0">{
                                newFocus = PanePackages
                        }</span> else<span class="cov8" title="1"> {
                                newFocus = PaneServices
                        }</span>
                } else<span class="cov8" title="1"> {
                        newFocus = PaneLogs
                }</span>
        }

        // Update focus if changed
        <span class="cov8" title="1">if m.focused != newFocus </span><span class="cov8" title="1">{
                m.focused = newFocus
        }</span>

        // Handle mouse wheel scrolling in logs pane
        <span class="cov8" title="1">if newFocus == PaneLogs </span><span class="cov8" title="1">{
                if msg.Type == tea.MouseWheelUp </span><span class="cov8" title="1">{
                        // Scroll up multiple times for better mouse feel
                        for i := 0; i &lt; 3; i++ </span><span class="cov8" title="1">{
                                m.logView.ScrollUp()
                        }</span>
                } else<span class="cov8" title="1"> if msg.Type == tea.MouseWheelDown </span><span class="cov0" title="0">{
                        // Scroll down multiple times for better mouse feel
                        for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                                m.logView.ScrollDown()
                        }</span>
                }
        }

        <span class="cov8" title="1">return m, nil</span>
}

// Init initializes the model.
func (m *Model) Init() tea.Cmd <span class="cov8" title="1">{
        return tea.Batch(
                m.tickCmd(),
                m.activityTickCmd(),
                m.pollServicesCmd(),
                m.splashTickCmd(),
                m.spinner.Tick,
        )
}</span>

type splashDoneMsg struct{}
type splashTickMsg struct{}

func (m *Model) tickCmd() tea.Cmd <span class="cov8" title="1">{
        return tea.Tick(2*time.Second, func(t time.Time) tea.Msg </span><span class="cov0" title="0">{
                return tickMsg(t)
        }</span>)
}

func (m *Model) activityTickCmd() tea.Cmd <span class="cov8" title="1">{
        return tea.Tick(100*time.Millisecond, func(t time.Time) tea.Msg </span><span class="cov0" title="0">{
                return activityTickMsg(t)
        }</span>)
}

func (m *Model) progressTickCmd() tea.Cmd <span class="cov0" title="0">{
        return tea.Tick(200*time.Millisecond, func(t time.Time) tea.Msg </span><span class="cov0" title="0">{
                return progressTickMsg(t)
        }</span>)
}

func (m *Model) splashTickCmd() tea.Cmd <span class="cov8" title="1">{
        return tea.Tick(50*time.Millisecond, func(t time.Time) tea.Msg </span><span class="cov0" title="0">{
                return splashTickMsg{}
        }</span>)
}

func (m *Model) pollServicesCmd() tea.Cmd <span class="cov8" title="1">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                return pollServicesMsg{}
        }</span>
}

func (m *Model) pollLogsCmd() tea.Cmd <span class="cov0" title="0">{
        // Capture current state for the closure
        p := m.currentProject()
        services := m.services

        return func() tea.Msg </span><span class="cov0" title="0">{
                if p == nil || len(services) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Create client in the goroutine
                <span class="cov0" title="0">socketPath := filepath.Join(p.Path, ".devenv", "run", "pc.sock")
                client := compose.NewClient(socketPath)
                if err := client.Connect(); err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Fetch logs for all services
                <span class="cov0" title="0">logsByService := make(map[string][]string)
                for _, svc := range services </span><span class="cov0" title="0">{
                        logs, err := client.GetLogs(svc.Name, 0, 100)
                        if err == nil &amp;&amp; len(logs) &gt; 0 </span><span class="cov0" title="0">{
                                logsByService[svc.Name] = logs
                        }</span>
                }

                <span class="cov0" title="0">if len(logsByService) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">return logsUpdatedMsg{logsByService: logsByService}</span>
        }
}

// startProjectCmd starts an idle project using devenv up -d
func (m *Model) startProjectCmd(p *registry.Project) tea.Cmd <span class="cov0" title="0">{
        projectPath := p.Path
        projectName := p.Name
        return func() tea.Msg </span><span class="cov0" title="0">{
                cmd := exec.Command("devenv", "up", "-d")
                cmd.Dir = projectPath
                output, err := cmd.CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        // Enhance error message with command output
                        if len(output) &gt; 0 </span><span class="cov0" title="0">{
                                err = fmt.Errorf("%v: %s", err, string(output))
                        }</span>
                }
                <span class="cov0" title="0">return projectStartedMsg{project: projectName, err: err}</span>
        }
}

// startServiceCmd starts a specific service
func (m *Model) startServiceCmd(client *compose.Client, serviceName string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                err := client.StartProcess(serviceName)
                return serviceOperationMsg{
                        service:   serviceName,
                        operation: "start",
                        err:       err,
                }
        }</span>
}

// stopServiceCmd stops a specific service
func (m *Model) stopServiceCmd(client *compose.Client, serviceName string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                err := client.StopProcess(serviceName)
                return serviceOperationMsg{
                        service:   serviceName,
                        operation: "stop",
                        err:       err,
                }
        }</span>
}

// restartServiceCmd restarts a specific service
func (m *Model) restartServiceCmd(client *compose.Client, serviceName string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                err := client.RestartProcess(serviceName)
                return serviceOperationMsg{
                        service:   serviceName,
                        operation: "restart",
                        err:       err,
                }
        }</span>
}

// stopProjectCmd stops a running project
func (m *Model) stopProjectCmd(p *registry.Project) tea.Cmd <span class="cov0" title="0">{
        projectPath := p.Path
        projectName := p.Name
        return func() tea.Msg </span><span class="cov0" title="0">{
                // First try to use the API if socket exists
                socketPath := filepath.Join(projectPath, ".devenv", "run", "pc.sock")
                client := compose.NewClient(socketPath)
                if err := client.Connect(); err == nil </span><span class="cov0" title="0">{
                        err = client.ShutdownProject()
                        if err != nil </span><span class="cov0" title="0">{
                                err = fmt.Errorf("API shutdown failed: %v", err)
                        }</span>
                        <span class="cov0" title="0">return projectStoppedMsg{project: projectName, err: err}</span>
                }
                // Fallback to devenv down
                <span class="cov0" title="0">cmd := exec.Command("devenv", "down")
                cmd.Dir = projectPath
                output, err := cmd.CombinedOutput()
                if err != nil </span><span class="cov0" title="0">{
                        // Enhance error message with command output
                        if len(output) &gt; 0 </span><span class="cov0" title="0">{
                                err = fmt.Errorf("%v: %s", err, string(output))
                        }</span>
                }
                <span class="cov0" title="0">return projectStoppedMsg{project: projectName, err: err}</span>
        }
}

// editConfigCmd opens the config file in $EDITOR
func (m *Model) editConfigCmd() tea.Cmd <span class="cov0" title="0">{
        // Get editor from environment, default to vi
        editor := os.Getenv("EDITOR")
        if editor == "" </span><span class="cov0" title="0">{
                editor = "vi"
        }</span>

        // Get config path
        <span class="cov0" title="0">configPath := config.Path()

        // Use tea.ExecProcess to suspend TUI and run editor
        c := exec.Command(editor, configPath)
        return tea.ExecProcess(c, func(err error) tea.Msg </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return configEditedMsg{config: nil, err: err}
                }</span>

                // Reload config after editing
                <span class="cov0" title="0">newConfig, loadErr := config.Load(configPath)
                if loadErr != nil </span><span class="cov0" title="0">{
                        return configEditedMsg{config: nil, err: fmt.Errorf("failed to reload config: %v", loadErr)}
                }</span>

                // Return the new config in the message
                <span class="cov0" title="0">return configEditedMsg{config: newConfig, err: nil}</span>
        })
}

// Update handles messages and updates the model.
func (m *Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        var cmds []tea.Cmd

        // Settings mode - delegate to settings panel
        if m.showSettings </span><span class="cov0" title="0">{
                var cmd tea.Cmd
                m.settings, cmd = m.settings.Update(msg)

                // Check if modal was closed (via cancel/Esc)
                if !m.settings.IsVisible() </span><span class="cov0" title="0">{
                        m.showSettings = false
                        // Restart tickers that were paused while settings modal was open
                        return m, tea.Batch(
                                cmd,
                                m.tickCmd(),
                                m.activityTickCmd(),
                                m.pollServicesCmd(),
                        )
                }</span>

                <span class="cov0" title="0">return m, cmd</span>
        }

        // Confirm dialog - delegate to confirm dialog
        <span class="cov8" title="1">if m.confirm.IsVisible() </span><span class="cov0" title="0">{
                var cmd tea.Cmd
                m.confirm, cmd = m.confirm.Update(msg)
                // Check if dialog was closed
                if !m.confirm.IsVisible() </span><span class="cov0" title="0">{
                        // Restart tickers that were paused while confirm dialog was open
                        return m, tea.Batch(
                                cmd,
                                m.tickCmd(),
                                m.activityTickCmd(),
                                m.pollServicesCmd(),
                        )
                }</span>
                <span class="cov0" title="0">return m, cmd</span>
        }

        <span class="cov8" title="1">switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov8" title="1">
                return m.handleKeyPress(msg)</span>

        case tea.MouseMsg:<span class="cov8" title="1">
                // Handle mouse events for focus following
                return m.handleMouseEvent(msg)</span>

        case tea.WindowSizeMsg:<span class="cov8" title="1">
                m.width = msg.Width
                m.height = msg.Height
                m.logView.SetSize(m.width-m.config.UI.SidebarWidth-8, m.height/2)
                m.splash.SetSize(m.width, m.height)
                m.settings.SetSize(m.width, m.height)
                m.helpPanel.SetSize(m.width, m.height)
                m.alertsPanel.SetSize(m.width, m.height)
                m.toast = NewToastManager(m.styles, m.width-10)</span>

        case spinner.TickMsg:<span class="cov0" title="0">
                var cmd tea.Cmd
                m.spinner, cmd = m.spinner.Update(msg)
                return m, cmd</span>

        case splashTickMsg:<span class="cov0" title="0">
                if m.showSplash </span><span class="cov0" title="0">{
                        // Advance animation frame for wave effect
                        m.splash.Tick()

                        // Increment progress by ~10% each tick (50ms intervals = ~500ms total)
                        newProgress := m.splash.Progress() + 0.1
                        m.splash.SetProgress(newProgress)

                        if newProgress &gt;= 1.0 </span><span class="cov0" title="0">{
                                // Hide splash when complete
                                m.showSplash = false
                                m.splash.Hide()
                        }</span> else<span class="cov0" title="0"> {
                                // Continue ticking
                                cmds = append(cmds, m.splashTickCmd())
                        }</span>
                }

        case splashDoneMsg:<span class="cov0" title="0">
                m.showSplash = false
                m.splash.Hide()</span>

        case tickMsg:<span class="cov0" title="0">
                m.updateDisplayedProjects()
                cmds = append(cmds, m.tickCmd())
                cmds = append(cmds, m.pollServicesCmd())</span>

        case activityTickMsg:<span class="cov0" title="0">
                // Increment animation frame and update table if we have services
                if len(m.services) &gt; 0 </span><span class="cov0" title="0">{
                        m.activityFrame++

                        // Update flash intensity decay for state transitions
                        // Flash decays over ~1.5 seconds with exponential falloff
                        for serviceName, changeTime := range m.stateChangeTime </span><span class="cov0" title="0">{
                                elapsed := time.Since(changeTime).Seconds()
                                if elapsed &gt;= 1.5 </span><span class="cov0" title="0">{
                                        // Flash complete, remove from tracking
                                        delete(m.stateFlashIntensity, serviceName)
                                        delete(m.stateChangeTime, serviceName)
                                }</span> else<span class="cov0" title="0"> {
                                        // Exponential decay: intensity goes from 1.0 to 0.0 over 1.5 seconds
                                        // Using e^(-3*t) for smooth fade
                                        m.stateFlashIntensity[serviceName] = 1.0 * (1.0 - elapsed/1.5)
                                }</span>
                        }

                        <span class="cov0" title="0">m.updateServicesTable()</span>
                }
                <span class="cov0" title="0">cmds = append(cmds, m.activityTickCmd())</span>

        case progressTickMsg:<span class="cov0" title="0">
                // Update loading progress for ongoing operations
                if m.loadingOp != "" &amp;&amp; !m.loadingStarted.IsZero() </span><span class="cov0" title="0">{
                        elapsed := time.Since(m.loadingStarted).Seconds()

                        // Estimate stages based on operation type
                        var stage string

                        switch m.loadingOp </span>{
                        case "Starting":<span class="cov0" title="0">
                                if elapsed &lt; 2.5 </span><span class="cov0" title="0">{
                                        stage = "Initializing environment..."
                                        m.loadingProgress = elapsed / 2.5 * 0.3 // 0-30%
                                }</span> else<span class="cov0" title="0"> if elapsed &lt; 5.5 </span><span class="cov0" title="0">{
                                        stage = "Starting services..."
                                        m.loadingProgress = 0.3 + ((elapsed-2.5)/3.0)*0.4 // 30-70%
                                }</span> else<span class="cov0" title="0"> {
                                        stage = "Services online"
                                        m.loadingProgress = 0.7 + ((elapsed-5.5)/2.5)*0.3 // 70-100%
                                }</span>

                        case "Stopping":<span class="cov0" title="0">
                                if elapsed &lt; 3.0 </span><span class="cov0" title="0">{
                                        stage = "Stopping services..."
                                        m.loadingProgress = elapsed / 3.0 * 0.6 // 0-60%
                                }</span> else<span class="cov0" title="0"> {
                                        stage = "Cleaning up..."
                                        m.loadingProgress = 0.6 + ((elapsed-3.0)/2.0)*0.4 // 60-100%
                                }</span>
                        }

                        // Cap at 95% until operation actually completes
                        <span class="cov0" title="0">if m.loadingProgress &gt; 0.95 </span><span class="cov0" title="0">{
                                m.loadingProgress = 0.95
                        }</span>

                        <span class="cov0" title="0">m.loadingStage = stage
                        cmds = append(cmds, m.progressTickCmd())</span>
                }

        case pollServicesMsg:<span class="cov0" title="0">
                // Poll the currently selected project
                if p := m.currentProject(); p != nil </span><span class="cov0" title="0">{
                        client := m.getOrCreateClient(p)
                        if client != nil </span><span class="cov0" title="0">{
                                status, err := client.GetStatus()
                                return m, func() tea.Msg </span><span class="cov0" title="0">{
                                        if err != nil </span><span class="cov0" title="0">{
                                                return servicesUpdatedMsg{nil, err}
                                        }</span>
                                        <span class="cov0" title="0">return servicesUpdatedMsg{status.Processes, nil}</span>
                                }
                        }
                }

        case servicesUpdatedMsg:<span class="cov0" title="0">
                if msg.err == nil </span><span class="cov0" title="0">{
                        oldServices := m.services
                        m.services = msg.services

                        // Sort services alphabetically
                        sort.Slice(m.services, func(i, j int) bool </span><span class="cov0" title="0">{
                                return m.services[i].Name &lt; m.services[j].Name
                        }</span>)

                        // Update table rows
                        <span class="cov0" title="0">m.updateServicesTable()

                        // Update health monitor and check for state changes
                        for _, svc := range msg.services </span><span class="cov0" title="0">{
                                projectName := ""
                                if p := m.currentProject(); p != nil </span><span class="cov0" title="0">{
                                        projectName = p.Name
                                }</span>
                                <span class="cov0" title="0">event := m.health.UpdateService(projectName, svc.Name, svc.IsRunning, svc.ExitCode)
                                if event != nil </span><span class="cov0" title="0">{
                                        cmds = append(cmds, func() tea.Msg </span><span class="cov0" title="0">{
                                                return healthEventMsg(*event)
                                        }</span>)
                                }

                                // Detect state transitions for flash animation
                                <span class="cov0" title="0">currentState := "Stopped"
                                if svc.IsRunning </span><span class="cov0" title="0">{
                                        currentState = "Running"
                                }</span>
                                <span class="cov0" title="0">lastState, exists := m.serviceStates[svc.Name]
                                if exists &amp;&amp; lastState != currentState </span><span class="cov0" title="0">{
                                        // State changed! Record timestamp and start flash animation
                                        m.stateChangeTime[svc.Name] = time.Now()
                                        m.stateFlashIntensity[svc.Name] = 1.0 // Start at maximum brightness
                                }</span>
                                <span class="cov0" title="0">m.serviceStates[svc.Name] = currentState

                                // Record CPU and memory history for sparklines (keep last 10 readings)
                                if svc.IsRunning </span><span class="cov0" title="0">{
                                        // Update CPU history
                                        cpuHist := m.cpuHistory[svc.Name]
                                        cpuHist = append(cpuHist, svc.CPU)
                                        if len(cpuHist) &gt; 10 </span><span class="cov0" title="0">{
                                                cpuHist = cpuHist[len(cpuHist)-10:] // Keep only last 10
                                        }</span>
                                        <span class="cov0" title="0">m.cpuHistory[svc.Name] = cpuHist

                                        // Update memory history
                                        memHist := m.memHistory[svc.Name]
                                        memHist = append(memHist, svc.Mem)
                                        if len(memHist) &gt; 10 </span><span class="cov0" title="0">{
                                                memHist = memHist[len(memHist)-10:] // Keep only last 10
                                        }</span>
                                        <span class="cov0" title="0">m.memHistory[svc.Name] = memHist</span>
                                }
                        }

                        // Clamp selected service
                        <span class="cov0" title="0">if m.selectedService &gt;= len(m.services) </span><span class="cov0" title="0">{
                                m.selectedService = len(m.services) - 1
                                if m.selectedService &lt; 0 </span><span class="cov0" title="0">{
                                        m.selectedService = 0
                                }</span>
                        }
                        // Update table cursor
                        <span class="cov0" title="0">m.servicesTable.SetCursor(m.selectedService)

                        // Poll logs after services update
                        cmds = append(cmds, m.pollLogsCmd())

                        _ = oldServices</span> // Suppress unused warning
                }

        case logsUpdatedMsg:<span class="cov0" title="0">
                if msg.err == nil &amp;&amp; len(msg.logsByService) &gt; 0 </span><span class="cov0" title="0">{
                        for service, logs := range msg.logsByService </span><span class="cov0" title="0">{
                                if len(logs) == 0 </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                // Find where new logs start (after last seen message)
                                <span class="cov0" title="0">lastSeen := m.lastLogMsg[service]
                                startIdx := 0
                                if lastSeen != "" </span><span class="cov0" title="0">{
                                        for i, log := range logs </span><span class="cov0" title="0">{
                                                if log == lastSeen </span><span class="cov0" title="0">{
                                                        startIdx = i + 1
                                                        break</span>
                                                }
                                        }
                                }

                                // Add new logs (logs come oldest-first from API)
                                <span class="cov0" title="0">newLogCount := 0
                                for i := startIdx; i &lt; len(logs); i++ </span><span class="cov0" title="0">{
                                        // Try to parse timestamp from log line, fall back to now
                                        ts, ok := ParseLogTimestamp(logs[i])
                                        if !ok </span><span class="cov0" title="0">{
                                                ts = time.Now()
                                        }</span>
                                        <span class="cov0" title="0">m.logView.AddEntry(LogEntry{
                                                Timestamp: ts,
                                                Service:   service,
                                                Level:     DetectLogLevel(logs[i]),
                                                Message:   logs[i],
                                        })
                                        newLogCount++</span>
                                }

                                // Track last message seen
                                <span class="cov0" title="0">m.lastLogMsg[service] = logs[len(logs)-1]

                                // Record log activity timestamp if new logs were added
                                if newLogCount &gt; 0 </span><span class="cov0" title="0">{
                                        m.logActivity[service] = time.Now()
                                }</span>
                        }
                }

        case healthEventMsg:<span class="cov0" title="0">
                event := health.Event(msg)
                // Add to alert history
                m.alerts.Add(Alert{
                        Type:      alertTypeFromHealthEvent(event.Type),
                        Project:   event.Project,
                        Service:   event.Service,
                        Message:   event.Type.String(),
                        Timestamp: event.Timestamp,
                })

                // Show toast for crashes
                if event.Type == health.EventServiceCrashed </span><span class="cov0" title="0">{
                        m.toast.Show(
                                fmt.Sprintf("%s crashed (exit %d)", event.Service, event.ExitCode),
                                ToastError,
                                5*time.Second,
                        )
                        cmds = append(cmds, m.toast.TickCmd())

                        // System notification
                        if m.notifier.IsEnabled() </span><span class="cov0" title="0">{
                                _ = m.notifier.ServiceCrashed(event.Project, event.Service, event.ExitCode)
                        }</span>
                } else<span class="cov0" title="0"> if event.Type == health.EventServiceRecovered </span><span class="cov0" title="0">{
                        m.toast.Show(
                                fmt.Sprintf("%s recovered", event.Service),
                                ToastInfo,
                                3*time.Second,
                        )
                        cmds = append(cmds, m.toast.TickCmd())
                }</span>

        case projectStartedMsg:<span class="cov0" title="0">
                // Clear loading state
                m.loadingOp = ""
                m.loadingProject = ""
                m.loadingProgress = 0
                m.loadingStage = ""
                m.loadingStarted = time.Time{}
                if msg.err != nil </span><span class="cov0" title="0">{
                        m.toast.Show(fmt.Sprintf("Failed to start %s: %v", msg.project, msg.err), ToastError, 5*time.Second)
                }</span> else<span class="cov0" title="0"> {
                        m.toast.Show(fmt.Sprintf("%s started", msg.project), ToastSuccess, 3*time.Second)
                        // Update project state cache to Running to prevent repeated start attempts
                        if p := m.currentProject(); p != nil &amp;&amp; p.Name == msg.project </span><span class="cov0" title="0">{
                                m.projectStates[p.Path] = registry.StateRunning
                        }</span>
                }
                <span class="cov0" title="0">cmds = append(cmds, m.toast.TickCmd())
                cmds = append(cmds, m.pollServicesCmd())</span>

        case projectStoppedMsg:<span class="cov0" title="0">
                // Clear loading state
                m.loadingOp = ""
                m.loadingProject = ""
                m.loadingProgress = 0
                m.loadingStage = ""
                m.loadingStarted = time.Time{}
                if msg.err != nil </span><span class="cov0" title="0">{
                        m.toast.Show(fmt.Sprintf("Failed to stop %s: %v", msg.project, msg.err), ToastError, 5*time.Second)
                }</span> else<span class="cov0" title="0"> {
                        m.toast.Show(fmt.Sprintf("%s stopped", msg.project), ToastSuccess, 3*time.Second)
                        // Clear services and logs for stopped project
                        m.services = nil
                        m.logView.buffer.Clear()
                        // Update project state cache to Idle to prevent state confusion
                        if p := m.currentProject(); p != nil &amp;&amp; p.Name == msg.project </span><span class="cov0" title="0">{
                                m.projectStates[p.Path] = registry.StateIdle
                        }</span>
                }
                <span class="cov0" title="0">cmds = append(cmds, m.toast.TickCmd())</span>

        case serviceOperationMsg:<span class="cov0" title="0">
                if msg.err != nil </span><span class="cov0" title="0">{
                        m.toast.Show(
                                fmt.Sprintf("Failed to %s %s: %v", msg.operation, msg.service, msg.err),
                                ToastError,
                                5*time.Second,
                        )
                }</span> else<span class="cov0" title="0"> {
                        m.toast.Show(
                                fmt.Sprintf("%s %sed", msg.service, msg.operation),
                                ToastSuccess,
                                2*time.Second,
                        )
                }</span>
                <span class="cov0" title="0">cmds = append(cmds, m.toast.TickCmd())
                cmds = append(cmds, m.pollServicesCmd())</span>

        case settingsSavedMsg:<span class="cov0" title="0">
                m.toast.Show("Settings saved", ToastSuccess, 2*time.Second)
                // Reload styles if theme changed
                m.styles = NewStyles(GetTheme(m.config.UI.Theme))

                // Update delegate with new styles
                newDelegate := &amp;projectDelegate{styles: m.styles, model: m}
                m.projectsList.SetDelegate(newDelegate)

                // Update table styles
                tableStyle := table.DefaultStyles()
                tableStyle.Header = tableStyle.Header.
                        BorderStyle(lipgloss.NormalBorder()).
                        BorderForeground(m.styles.theme.Muted).
                        BorderBottom(true).
                        Bold(true).
                        Foreground(m.styles.theme.Primary)
                tableStyle.Selected = tableStyle.Selected.
                        Foreground(m.styles.theme.Primary).
                        Bold(true)
                // Keep default cell padding
                m.servicesTable.SetStyles(tableStyle)

                // Update spinner style
                m.spinner.Style = lipgloss.NewStyle().Foreground(m.styles.theme.Primary)

                // Restart tickers that were paused while settings modal was open
                cmds = append(cmds, m.tickCmd())
                cmds = append(cmds, m.activityTickCmd())
                cmds = append(cmds, m.pollServicesCmd())
                cmds = append(cmds, m.toast.TickCmd())</span>

        case settingsSaveErrorMsg:<span class="cov0" title="0">
                m.toast.Show(fmt.Sprintf("Failed to save settings: %v", msg.err), ToastError, 5*time.Second)
                cmds = append(cmds, m.toast.TickCmd())</span>

        case projectDeletedMsg:<span class="cov0" title="0">
                m.toast.Show(fmt.Sprintf("%s removed from registry", msg.project), ToastSuccess, 2*time.Second)
                m.updateDisplayedProjects()
                cmds = append(cmds, m.toast.TickCmd())</span>

        case projectHiddenMsg:<span class="cov0" title="0">
                if msg.hidden </span><span class="cov0" title="0">{
                        m.toast.Show(fmt.Sprintf("%s hidden", msg.project), ToastInfo, 2*time.Second)
                }</span> else<span class="cov0" title="0"> {
                        m.toast.Show(fmt.Sprintf("%s shown", msg.project), ToastInfo, 2*time.Second)
                }</span>
                <span class="cov0" title="0">m.updateDisplayedProjects()
                cmds = append(cmds, m.toast.TickCmd())</span>

        case projectRepairedMsg:<span class="cov0" title="0">
                if msg.err != nil </span><span class="cov0" title="0">{
                        m.toast.Show(fmt.Sprintf("Failed to repair %s: %v", msg.project, msg.err), ToastError, 5*time.Second)
                }</span> else<span class="cov0" title="0"> {
                        m.toast.Show(fmt.Sprintf("%s repaired - ready to start", msg.project), ToastSuccess, 3*time.Second)
                }</span>
                <span class="cov0" title="0">m.updateDisplayedProjects()
                cmds = append(cmds, m.toast.TickCmd())</span>

        case configEditedMsg:<span class="cov0" title="0">
                if msg.err != nil </span><span class="cov0" title="0">{
                        m.toast.Show(fmt.Sprintf("Failed to edit config: %v", msg.err), ToastError, 5*time.Second)
                }</span> else<span class="cov0" title="0"> {
                        // Update config in model
                        m.config = msg.config
                        // Reload styles with new theme
                        m.styles = NewStyles(GetTheme(m.config.UI.Theme))
                        // Update settings panel with new config
                        m.settings = NewSettingsPanel(m.config, m.styles, m.width, m.height)
                        m.toast.Show("Config reloaded", ToastSuccess, 2*time.Second)
                }</span>
                <span class="cov0" title="0">cmds = append(cmds, m.toast.TickCmd())</span>

        case ToastTickMsg:<span class="cov0" title="0">
                var cmd tea.Cmd
                m.toast, cmd = m.toast.Update(msg)
                if cmd != nil </span><span class="cov0" title="0">{
                        cmds = append(cmds, cmd)
                }</span>
        }

        <span class="cov8" title="1">if len(cmds) &gt; 0 </span><span class="cov0" title="0">{
                return m, tea.Batch(cmds...)
        }</span>
        <span class="cov8" title="1">return m, nil</span>
}

func alertTypeFromHealthEvent(t health.EventType) AlertType <span class="cov0" title="0">{
        switch t </span>{
        case health.EventServiceCrashed:<span class="cov0" title="0">
                return AlertServiceCrashed</span>
        case health.EventServiceRecovered:<span class="cov0" title="0">
                return AlertServiceRecovered</span>
        case health.EventServiceStarted:<span class="cov0" title="0">
                return AlertProjectStarted</span>
        case health.EventServiceStopped:<span class="cov0" title="0">
                return AlertProjectStopped</span>
        default:<span class="cov0" title="0">
                return AlertInfo</span>
        }
}

func (m *Model) getOrCreateClient(p *registry.Project) *compose.Client <span class="cov0" title="0">{
        if client, ok := m.clients[p.Path]; ok </span><span class="cov0" title="0">{
                if client.IsConnected() </span><span class="cov0" title="0">{
                        return client
                }</span>
                // Try to reconnect
                <span class="cov0" title="0">delete(m.clients, p.Path)</span>
        }

        // Try to connect to process-compose socket
        // devenv creates a symlink at .devenv/run pointing to /run/user/$UID/devenv-$HASH
        <span class="cov0" title="0">socketPath := filepath.Join(p.Path, ".devenv", "run", "pc.sock")
        client := compose.NewClient(socketPath)
        if err := client.Connect(); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">m.clients[p.Path] = client
        return client</span>
}

func (m *Model) handleKeyPress(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov8" title="1">{
        // Splash screen - any key dismisses
        if m.showSplash </span><span class="cov0" title="0">{
                m.showSplash = false
                m.splash.Hide()
                return m, nil
        }</span>

        // Help mode - delegate to help panel
        <span class="cov8" title="1">if m.showHelp </span><span class="cov0" title="0">{
                var cmd tea.Cmd
                m.helpPanel, cmd = m.helpPanel.Update(msg)

                // Check if modal was closed
                if !m.helpPanel.IsVisible() </span><span class="cov0" title="0">{
                        m.showHelp = false
                        // Restart tickers that were paused while help modal was open
                        return m, tea.Batch(
                                cmd,
                                m.tickCmd(),
                                m.activityTickCmd(),
                                m.pollServicesCmd(),
                        )
                }</span>

                <span class="cov0" title="0">return m, cmd</span>
        }

        // Alerts modal - delegate to panel
        <span class="cov8" title="1">if m.alertsPanel.IsVisible() </span><span class="cov0" title="0">{
                _, cmd := m.alertsPanel.Update(msg)
                // Check if modal was closed
                if !m.alertsPanel.IsVisible() </span><span class="cov0" title="0">{
                        // Restart tickers that were paused while alerts modal was open
                        return m, tea.Batch(
                                cmd,
                                m.tickCmd(),
                                m.activityTickCmd(),
                                m.pollServicesCmd(),
                        )
                }</span>
                <span class="cov0" title="0">return m, cmd</span>
        }

        // Log search input mode
        <span class="cov8" title="1">if m.searchMode </span><span class="cov0" title="0">{
                switch msg.Type </span>{
                case tea.KeyEsc:<span class="cov0" title="0">
                        m.searchMode = false
                        m.searchInput.Reset()
                        m.searchInput.Blur()
                        m.logView.ClearSearch()
                        // Restore follow mode when canceling search
                        m.logView.SetFollow(m.followBeforeSearch)
                        return m, nil</span>
                case tea.KeyEnter:<span class="cov0" title="0">
                        m.searchMode = false
                        m.searchInput.Blur()
                        // Keep search active, just exit input mode
                        return m, nil</span>
                default:<span class="cov0" title="0">
                        // Delegate to textinput for all other keys
                        var cmd tea.Cmd
                        m.searchInput, cmd = m.searchInput.Update(msg)
                        m.logView.SetSearch(m.searchInput.Value())
                        return m, cmd</span>
                }
        }

        // Global keys
        <span class="cov8" title="1">switch </span>{
        case key.Matches(msg, m.keys.Quit):<span class="cov0" title="0">
                return m, tea.Quit</span>
        case key.Matches(msg, m.keys.Shutdown):<span class="cov0" title="0">
                // Shutdown all services
                for _, client := range m.clients </span><span class="cov0" title="0">{
                        _ = client.ShutdownProject()
                }</span>
                <span class="cov0" title="0">return m, tea.Quit</span>
        case key.Matches(msg, m.keys.Help):<span class="cov0" title="0">
                m.helpPanel.Show()
                m.showHelp = true
                return m, nil</span>
        case key.Matches(msg, m.keys.Tab):<span class="cov0" title="0">
                m.cycleFocus()
                return m, nil</span>
        case key.Matches(msg, m.keys.ShiftTab):<span class="cov0" title="0">
                m.cycleFocusReverse()
                return m, nil</span>
        case key.Matches(msg, m.keys.Settings):<span class="cov0" title="0">
                cmd := m.settings.Show()
                m.showSettings = true
                return m, cmd</span>
        case key.Matches(msg, m.keys.EditConfig):<span class="cov0" title="0">
                return m, m.editConfigCmd()</span>
        case key.Matches(msg, m.keys.History):<span class="cov0" title="0">
                if m.alertsPanel.IsVisible() </span><span class="cov0" title="0">{
                        m.alertsPanel.Hide()
                }</span> else<span class="cov0" title="0"> {
                        m.alertsPanel.Show()
                }</span>
                <span class="cov0" title="0">return m, nil</span>
        case msg.String() == "p":<span class="cov8" title="1">
                // Toggle between packages and services view
                return m, m.togglePackagesView()</span>
        case key.Matches(msg, m.keys.Back):<span class="cov0" title="0">
                // Don't handle Esc globally if sidebar is filtering or logs has active search
                if m.focused == PaneSidebar &amp;&amp; m.projectFilterMode </span><span class="cov0" title="0">{
                        // Let sidebar handler deal with it
                        return m.handleSidebarKey(msg)
                }</span>
                <span class="cov0" title="0">if m.focused == PaneLogs &amp;&amp; m.logView.IsSearchActive() </span><span class="cov0" title="0">{
                        // Let logs handler deal with it
                        return m.handleLogsKey(msg)
                }</span>
                <span class="cov0" title="0">return m, nil</span>
        }

        // Navigation keys (skip if sidebar is filtering - those keys might be part of search)
        <span class="cov0" title="0">if m.focused != PaneSidebar || !m.projectFilterMode </span><span class="cov0" title="0">{
                switch </span>{
                case key.Matches(msg, m.keys.Up):<span class="cov0" title="0">
                        cmd := m.moveUp()
                        return m, cmd</span>
                case key.Matches(msg, m.keys.Down):<span class="cov0" title="0">
                        cmd := m.moveDown()
                        return m, cmd</span>
                }
        }

        // Pane-specific keys
        <span class="cov0" title="0">switch m.focused </span>{
        case PaneSidebar:<span class="cov0" title="0">
                return m.handleSidebarKey(msg)</span>
        case PaneServices:<span class="cov0" title="0">
                return m.handleServicesKey(msg)</span>
        case PaneLogs:<span class="cov0" title="0">
                return m.handleLogsKey(msg)</span>
        }

        <span class="cov0" title="0">return m, nil</span>
}

func (m *Model) handleSidebarKey(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        // Handle custom project filter mode
        if m.projectFilterMode </span><span class="cov0" title="0">{
                switch msg.Type </span>{
                case tea.KeyEsc:<span class="cov0" title="0">
                        // Exit filter mode and clear
                        m.projectFilterMode = false
                        m.projectFilterInput = ""
                        m.updateDisplayedProjects()
                        return m, nil</span>
                case tea.KeyEnter:<span class="cov0" title="0">
                        // Keep filter applied, just exit input mode
                        m.projectFilterMode = false
                        return m, nil</span>
                case tea.KeyBackspace:<span class="cov0" title="0">
                        if len(m.projectFilterInput) &gt; 0 </span><span class="cov0" title="0">{
                                m.projectFilterInput = m.projectFilterInput[:len(m.projectFilterInput)-1]
                                m.updateDisplayedProjects()
                        }</span>
                        <span class="cov0" title="0">return m, nil</span>
                case tea.KeyRunes:<span class="cov0" title="0">
                        m.projectFilterInput += string(msg.Runes)
                        m.updateDisplayedProjects()
                        return m, nil</span>
                }
                <span class="cov0" title="0">return m, nil</span>
        }

        <span class="cov0" title="0">switch </span>{
        case key.Matches(msg, m.keys.Search) || msg.String() == "/":<span class="cov0" title="0">
                // Enter custom filter mode
                m.projectFilterMode = true
                m.projectFilterInput = ""
                return m, nil</span>
        case key.Matches(msg, m.keys.Select):<span class="cov0" title="0">
                // Enter - move focus to services pane
                // Services are already displayed from cursor movement
                m.focused = PaneServices
                return m, nil</span>
        case key.Matches(msg, m.keys.Start):<span class="cov0" title="0">
                // s - start project
                if p := m.currentProject(); p != nil </span><span class="cov0" title="0">{
                        // Don't allow starting if ANY loading operation is in progress
                        if m.loadingOp != "" </span><span class="cov0" title="0">{
                                return m, nil
                        }</span>

                        // Use cached state if available, otherwise detect fresh
                        <span class="cov0" title="0">state, hasCached := m.projectStates[p.Path]
                        if !hasCached </span><span class="cov0" title="0">{
                                state = p.DetectState()
                        }</span>

                        <span class="cov0" title="0">if state == registry.StateIdle || state == registry.StateStale </span><span class="cov0" title="0">{
                                // Start idle project with devenv up -d
                                m.loadingOp = "Starting"
                                m.loadingProject = p.Name
                                m.loadingProgress = 0.0
                                m.loadingStage = "Initializing..."
                                m.loadingStarted = time.Now()

                                // Immediately update cache to prevent re-entry
                                m.projectStates[p.Path] = registry.StateRunning

                                m.toast.Show(fmt.Sprintf("Starting %s...", p.Name), ToastInfo, 3*time.Second)
                                return m, tea.Batch(m.startProjectCmd(p), m.toast.TickCmd(), m.progressTickCmd())
                        }</span> else<span class="cov0" title="0"> if state == registry.StateRunning || state == registry.StateDegraded </span><span class="cov0" title="0">{
                                // Project already running - don't show progress, just inform
                                m.toast.Show("Project already running", ToastInfo, 2*time.Second)
                                return m, m.toast.TickCmd()
                        }</span>
                }
                <span class="cov0" title="0">return m, nil</span>
        case key.Matches(msg, m.keys.Stop):<span class="cov0" title="0">
                // x - stop project
                if p := m.currentProject(); p != nil </span><span class="cov0" title="0">{
                        // Don't allow stopping if ANY loading operation is in progress
                        if m.loadingOp != "" </span><span class="cov0" title="0">{
                                return m, nil
                        }</span>

                        <span class="cov0" title="0">state, hasCached := m.projectStates[p.Path]
                        if !hasCached </span><span class="cov0" title="0">{
                                state = p.DetectState()
                        }</span>

                        <span class="cov0" title="0">if state == registry.StateRunning || state == registry.StateDegraded </span><span class="cov0" title="0">{
                                m.loadingOp = "Stopping"
                                m.loadingProject = p.Name
                                m.loadingProgress = 0.0
                                m.loadingStage = "Stopping..."
                                m.loadingStarted = time.Now()

                                // Immediately update cache to prevent re-entry
                                m.projectStates[p.Path] = registry.StateIdle

                                m.toast.Show(fmt.Sprintf("Stopping %s...", p.Name), ToastInfo, 3*time.Second)
                                return m, tea.Batch(m.stopProjectCmd(p), m.toast.TickCmd(), m.progressTickCmd())
                        }</span> else<span class="cov0" title="0"> {
                                m.toast.Show("Project not running", ToastInfo, 2*time.Second)
                                return m, m.toast.TickCmd()
                        }</span>
                }
                <span class="cov0" title="0">return m, nil</span>
        case key.Matches(msg, m.keys.Delete):<span class="cov0" title="0">
                // d - delete project (with confirmation)
                if p := m.currentProject(); p != nil </span><span class="cov0" title="0">{
                        projectPath := p.Path
                        projectName := p.Name
                        m.confirm.Show(
                                fmt.Sprintf("Remove %s from registry?", projectName),
                                func() tea.Msg </span><span class="cov0" title="0">{
                                        // Delete the project
                                        if m.registry.RemoveProject(projectPath) </span><span class="cov0" title="0">{
                                                // Save registry
                                                regPath := registry.Path()
                                                _ = registry.Save(regPath, m.registry)
                                                return projectDeletedMsg{project: projectName}
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                },
                                func() tea.Msg <span class="cov0" title="0">{
                                        // Cancel - do nothing
                                        return nil
                                }</span>,
                        )
                }
                <span class="cov0" title="0">return m, nil</span>
        case key.Matches(msg, m.keys.Hide):<span class="cov0" title="0">
                // ctrl+h - toggle hidden
                if p := m.currentProject(); p != nil </span><span class="cov0" title="0">{
                        projectPath := p.Path
                        projectName := p.Name
                        if m.registry.ToggleHidden(projectPath) </span><span class="cov0" title="0">{
                                // Save registry
                                regPath := registry.Path()
                                _ = registry.Save(regPath, m.registry)
                                return m, func() tea.Msg </span><span class="cov0" title="0">{
                                        return projectHiddenMsg{project: projectName, hidden: p.Hidden}
                                }</span>
                        }
                }
                <span class="cov0" title="0">return m, nil</span>
        case key.Matches(msg, m.keys.Repair):<span class="cov0" title="0">
                // c - repair stale project
                if p := m.currentProject(); p != nil </span><span class="cov0" title="0">{
                        state := p.DetectState()
                        if state == registry.StateStale </span><span class="cov0" title="0">{
                                projectName := p.Name
                                m.confirm.Show(
                                        fmt.Sprintf("Clean up stale files for %s?", projectName),
                                        func() tea.Msg </span><span class="cov0" title="0">{
                                                // Repair the project
                                                err := p.Repair()
                                                return projectRepairedMsg{project: projectName, err: err}
                                        }</span>,
                                        func() tea.Msg <span class="cov0" title="0">{
                                                // Cancel - do nothing
                                                return nil
                                        }</span>,
                                )
                        }
                }
                <span class="cov0" title="0">return m, nil</span>
        }

        // Don't pass navigation keys to list component since we handle them ourselves
        // This prevents rendering glitches when the list tries to handle navigation too
        <span class="cov0" title="0">if key.Matches(msg, m.keys.Up) || key.Matches(msg, m.keys.Down) </span><span class="cov0" title="0">{
                return m, nil
        }</span>

        // Pass message to list component for filtering (handles '/' key)
        <span class="cov0" title="0">var cmd tea.Cmd
        m.projectsList, cmd = m.projectsList.Update(msg)

        // Sync selection after list update (in case filter changed)
        if selectedItem := m.projectsList.SelectedItem(); selectedItem != nil </span><span class="cov0" title="0">{
                if _, isProject := selectedItem.(projectListItem); isProject </span><span class="cov0" title="0">{
                        m.selectedProject = m.listIndexToProjectIndex(m.projectsList.Index())
                }</span>
        }

        <span class="cov0" title="0">return m, cmd</span>
}

func (m *Model) handleServicesKey(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch </span>{
        case key.Matches(msg, m.keys.Back):<span class="cov0" title="0">
                // Esc - go back to sidebar
                m.focused = PaneSidebar
                return m, nil</span>
        case key.Matches(msg, m.keys.Select):<span class="cov0" title="0">
                // Enter - filter logs to this service (stay in services pane)
                if m.selectedService &lt; len(m.services) </span><span class="cov0" title="0">{
                        currentFilter := m.logView.GetService()
                        selectedName := m.services[m.selectedService].Name
                        // Toggle: if already filtered to this service, show all
                        if currentFilter == selectedName </span><span class="cov0" title="0">{
                                m.logView.SetService("")
                        }</span> else<span class="cov0" title="0"> {
                                m.logView.SetService(selectedName)
                        }</span>
                }
                <span class="cov0" title="0">return m, nil</span>
        case key.Matches(msg, m.keys.Start):<span class="cov0" title="0">
                // s - start service
                if p := m.currentProject(); p != nil </span><span class="cov0" title="0">{
                        if client := m.getOrCreateClient(p); client != nil </span><span class="cov0" title="0">{
                                if m.selectedService &lt; len(m.services) </span><span class="cov0" title="0">{
                                        return m, m.startServiceCmd(client, m.services[m.selectedService].Name)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return m, nil</span>
        case key.Matches(msg, m.keys.Stop):<span class="cov0" title="0">
                // x - stop service
                if p := m.currentProject(); p != nil </span><span class="cov0" title="0">{
                        if client := m.getOrCreateClient(p); client != nil </span><span class="cov0" title="0">{
                                if m.selectedService &lt; len(m.services) </span><span class="cov0" title="0">{
                                        return m, m.stopServiceCmd(client, m.services[m.selectedService].Name)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return m, nil</span>
        case key.Matches(msg, m.keys.Restart):<span class="cov0" title="0">
                // r - restart service
                if p := m.currentProject(); p != nil </span><span class="cov0" title="0">{
                        if client := m.getOrCreateClient(p); client != nil </span><span class="cov0" title="0">{
                                if m.selectedService &lt; len(m.services) </span><span class="cov0" title="0">{
                                        return m, m.restartServiceCmd(client, m.services[m.selectedService].Name)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return m, nil</span>
        }
        <span class="cov0" title="0">return m, nil</span>
}

func (m *Model) handleLogsKey(msg tea.KeyMsg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch </span>{
        case key.Matches(msg, m.keys.Search) || msg.String() == "/":<span class="cov0" title="0">
                // / - enter search mode
                m.followBeforeSearch = m.logView.IsFollowing() // Save follow state
                m.searchMode = true
                m.searchInput.Reset()
                m.searchInput.Focus()
                return m, m.searchInput.Cursor.BlinkCmd()</span>
        case key.Matches(msg, m.keys.NextMatch):<span class="cov0" title="0">
                // n - next search match
                m.logView.NextMatch()
                return m, nil</span>
        case key.Matches(msg, m.keys.PrevMatch):<span class="cov0" title="0">
                // N - previous search match
                m.logView.PrevMatch()
                return m, nil</span>
        case key.Matches(msg, m.keys.Filter):<span class="cov0" title="0">
                // ctrl+f - toggle filter mode (show only matching lines)
                m.logView.ToggleFilter()
                return m, nil</span>
        case key.Matches(msg, m.keys.Back):<span class="cov0" title="0">
                // Esc - if search active, clear search first. Otherwise go back to services.
                if m.logView.IsSearchActive() </span><span class="cov0" title="0">{
                        m.logView.ClearSearch()
                        m.searchInput.Reset()
                        // Restore follow mode to previous state
                        m.logView.SetFollow(m.followBeforeSearch)
                        return m, nil
                }</span>
                // No search active, go back to services
                <span class="cov0" title="0">m.logView.SetService("") // Show all logs
                m.focused = PaneServices
                return m, nil</span>
        case key.Matches(msg, m.keys.Follow):<span class="cov0" title="0">
                m.logView.ToggleFollow()
                return m, nil</span>
        case key.Matches(msg, m.keys.Top):<span class="cov0" title="0">
                m.logView.ScrollToTop()
                return m, nil</span>
        case key.Matches(msg, m.keys.Bottom):<span class="cov0" title="0">
                m.logView.ScrollToBottom()
                return m, nil</span>
        case key.Matches(msg, m.keys.Up):<span class="cov0" title="0">
                m.logView.ScrollUp()
                return m, nil</span>
        case key.Matches(msg, m.keys.Down):<span class="cov0" title="0">
                m.logView.ScrollDown()
                return m, nil</span>
        }
        <span class="cov0" title="0">return m, nil</span>
}

func (m *Model) currentProject() *registry.Project <span class="cov8" title="1">{
        if len(m.displayedProjects) == 0 || m.selectedProject &gt;= len(m.displayedProjects) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return m.displayedProjects[m.selectedProject]</span>
}

const (
        minWidthForBothPanes = 140
)

// shouldShowBothPanes determines if there's enough space to show both Services and Packages panes.
func (m *Model) shouldShowBothPanes() bool <span class="cov8" title="1">{
        return m.width &gt;= minWidthForBothPanes
}</span>

// togglePackagesView switches between Services and Packages pane (for narrow terminals).
func (m *Model) togglePackagesView() tea.Cmd <span class="cov8" title="1">{
        m.showPackages = !m.showPackages
        return nil
}</span>

// updateDisplayedProjects rebuilds the sidebar display order (active first, then idle, alphabetical within each).
// It also caches the detected states to avoid inconsistent state during rendering.
func (m *Model) updateDisplayedProjects() <span class="cov8" title="1">{
        var active, idle []*registry.Project
        for _, p := range m.registry.Projects </span><span class="cov8" title="1">{
                state := p.DetectState()
                // Cache the state so we use consistent state during rendering
                m.projectStates[p.Path] = state

                // Apply filter if active
                if m.projectFilterInput != "" </span><span class="cov0" title="0">{
                        if !strings.Contains(strings.ToLower(p.Name), strings.ToLower(m.projectFilterInput)) </span><span class="cov0" title="0">{
                                continue</span> // Skip projects that don't match filter
                        }
                }

                <span class="cov8" title="1">if state == registry.StateRunning || state == registry.StateDegraded </span><span class="cov0" title="0">{
                        active = append(active, p)
                }</span> else<span class="cov8" title="1"> {
                        idle = append(idle, p)
                }</span>
        }

        // Sort each group alphabetically
        <span class="cov8" title="1">sort.Slice(active, func(i, j int) bool </span><span class="cov0" title="0">{
                return active[i].Name &lt; active[j].Name
        }</span>)
        <span class="cov8" title="1">sort.Slice(idle, func(i, j int) bool </span><span class="cov8" title="1">{
                return idle[i].Name &lt; idle[j].Name
        }</span>)

        <span class="cov8" title="1">m.displayedProjects = append(active, idle...)

        // Update list items with section headers
        var items []list.Item

        // Add ACTIVE section
        if len(active) &gt; 0 </span><span class="cov0" title="0">{
                items = append(items, sectionHeaderItem{title: "ACTIVE"})
                for _, p := range active </span><span class="cov0" title="0">{
                        items = append(items, projectListItem{
                                project: p,
                                state:   m.projectStates[p.Path],
                        })
                }</span>
        }

        // Add IDLE section
        <span class="cov8" title="1">if len(idle) &gt; 0 </span><span class="cov8" title="1">{
                items = append(items, sectionHeaderItem{title: "IDLE"})
                for _, p := range idle </span><span class="cov8" title="1">{
                        items = append(items, projectListItem{
                                project: p,
                                state:   m.projectStates[p.Path],
                        })
                }</span>
        }

        <span class="cov8" title="1">m.projectsList.SetItems(items)

        // Convert project index to list index (accounting for headers)
        listIndex := m.projectIndexToListIndex(m.selectedProject)
        m.projectsList.Select(listIndex)

        // Clamp selection
        if m.selectedProject &gt;= len(m.displayedProjects) </span><span class="cov8" title="1">{
                m.selectedProject = len(m.displayedProjects) - 1
                if m.selectedProject &lt; 0 </span><span class="cov8" title="1">{
                        m.selectedProject = 0
                }</span>
        }
        <span class="cov8" title="1">listIndex = m.projectIndexToListIndex(m.selectedProject)
        m.projectsList.Select(listIndex)

        // Ensure we're not on a header (this shouldn't happen, but safety check)
        if len(m.projectsList.Items()) &gt; 0 </span><span class="cov8" title="1">{
                if _, isHeader := m.projectsList.SelectedItem().(sectionHeaderItem); isHeader </span><span class="cov0" title="0">{
                        // Move to first non-header item
                        for i, item := range m.projectsList.Items() </span><span class="cov0" title="0">{
                                if _, isHeader := item.(sectionHeaderItem); !isHeader </span><span class="cov0" title="0">{
                                        m.projectsList.Select(i)
                                        m.selectedProject = m.listIndexToProjectIndex(i)
                                        break</span>
                                }
                        }
                }
        }
}

// projectIndexToListIndex converts a project index to a list index (accounting for section headers).
func (m *Model) projectIndexToListIndex(projectIndex int) int <span class="cov8" title="1">{
        if projectIndex &lt; 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">listIndex := 0
        projectsSeen := 0

        for _, item := range m.projectsList.Items() </span><span class="cov8" title="1">{
                if _, isHeader := item.(sectionHeaderItem); isHeader </span><span class="cov8" title="1">{
                        listIndex++
                        continue</span>
                }
                <span class="cov8" title="1">if projectsSeen == projectIndex </span><span class="cov8" title="1">{
                        return listIndex
                }</span>
                <span class="cov0" title="0">projectsSeen++
                listIndex++</span>
        }

        <span class="cov8" title="1">return listIndex</span>
}

// listIndexToProjectIndex converts a list index to a project index (skipping section headers).
func (m *Model) listIndexToProjectIndex(listIndex int) int <span class="cov8" title="1">{
        projectIndex := 0
        for i := 0; i &lt; listIndex &amp;&amp; i &lt; len(m.projectsList.Items()); i++ </span><span class="cov8" title="1">{
                if _, isHeader := m.projectsList.Items()[i].(sectionHeaderItem); !isHeader </span><span class="cov8" title="1">{
                        projectIndex++
                }</span>
        }
        <span class="cov8" title="1">return projectIndex</span>
}

func (m *Model) cycleFocus() <span class="cov8" title="1">{
        switch m.focused </span>{
        case PaneSidebar:<span class="cov8" title="1">
                m.focused = PaneServices</span>
        case PaneServices:<span class="cov8" title="1">
                // If both panes visible, go to packages next
                // Otherwise skip to logs
                if m.shouldShowBothPanes() </span><span class="cov0" title="0">{
                        m.focused = PanePackages
                }</span> else<span class="cov8" title="1"> {
                        m.focused = PaneLogs
                }</span>
        case PanePackages:<span class="cov0" title="0">
                m.focused = PaneLogs</span>
        case PaneLogs:<span class="cov8" title="1">
                m.focused = PaneSidebar</span>
        default:<span class="cov0" title="0">
                m.focused = PaneSidebar</span>
        }
}

func (m *Model) cycleFocusReverse() <span class="cov0" title="0">{
        switch m.focused </span>{
        case PaneSidebar:<span class="cov0" title="0">
                m.focused = PaneLogs</span>
        case PaneServices:<span class="cov0" title="0">
                m.focused = PaneSidebar</span>
        case PanePackages:<span class="cov0" title="0">
                m.focused = PaneServices</span>
        case PaneLogs:<span class="cov0" title="0">
                // If both panes visible, go to packages previous
                // Otherwise skip to services
                if m.shouldShowBothPanes() </span><span class="cov0" title="0">{
                        m.focused = PanePackages
                }</span> else<span class="cov0" title="0"> {
                        m.focused = PaneServices
                }</span>
        default:<span class="cov0" title="0">
                m.focused = PaneSidebar</span>
        }
}

// switchToCurrentProject updates the services display for the currently selected project
func (m *Model) switchToCurrentProject() <span class="cov8" title="1">{
        m.selectedService = 0
        m.services = nil // Clear services, will be repopulated
        m.lastLogMsg = make(map[string]string)           // Reset log tracking for new project
        m.logActivity = make(map[string]time.Time)       // Reset log activity tracking
        m.serviceStates = make(map[string]string)        // Reset state tracking
        m.stateChangeTime = make(map[string]time.Time)   // Reset state change times
        m.stateFlashIntensity = make(map[string]float64) // Reset flash intensity
        m.cpuHistory = make(map[string][]float64)        // Reset CPU history
        m.memHistory = make(map[string][]int64)          // Reset memory history
        m.logView.SetService("")                         // Clear service filter
        m.logView.buffer.Clear()                         // Clear old logs

        // Scan packages for new project
        project := m.currentProject()
        if project != nil </span><span class="cov8" title="1">{
                pkgs, err := packages.Scan(project.Path)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but don't block
                        pkgs = []packages.Package{}
                }</span>
                <span class="cov8" title="1">m.packagesView.SetPackages(pkgs)</span>
        } else<span class="cov8" title="1"> {
                m.packagesView.SetPackages([]packages.Package{})
        }</span>
}

func (m *Model) moveUp() tea.Cmd <span class="cov8" title="1">{
        switch m.focused </span>{
        case PaneSidebar:<span class="cov8" title="1">
                // Use list's cursor movement
                currentIdx := m.projectsList.Index()
                if currentIdx &gt; 0 </span><span class="cov8" title="1">{
                        m.projectsList.CursorUp()

                        // Skip over headers
                        for m.projectsList.Index() &gt; 0 </span><span class="cov8" title="1">{
                                if _, isHeader := m.projectsList.SelectedItem().(sectionHeaderItem); !isHeader </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                <span class="cov0" title="0">m.projectsList.CursorUp()</span>
                        }

                        // Update selectedProject to match
                        <span class="cov8" title="1">oldProject := m.selectedProject
                        m.selectedProject = m.listIndexToProjectIndex(m.projectsList.Index())

                        // If project changed, update services display immediately
                        if oldProject != m.selectedProject </span><span class="cov8" title="1">{
                                m.switchToCurrentProject()
                                return m.pollServicesCmd()
                        }</span>
                }
        case PaneServices:<span class="cov0" title="0">
                if m.selectedService &gt; 0 </span><span class="cov0" title="0">{
                        m.selectedService--
                        m.servicesTable.SetCursor(m.selectedService)
                }</span>
        case PaneLogs:<span class="cov0" title="0">
                m.logView.ScrollUp()</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (m *Model) moveDown() tea.Cmd <span class="cov8" title="1">{
        switch m.focused </span>{
        case PaneSidebar:<span class="cov8" title="1">
                // Use list's cursor movement
                maxIdx := len(m.projectsList.Items()) - 1
                if m.projectsList.Index() &lt; maxIdx </span><span class="cov8" title="1">{
                        m.projectsList.CursorDown()

                        // Skip over headers
                        for m.projectsList.Index() &lt; maxIdx </span><span class="cov8" title="1">{
                                if _, isHeader := m.projectsList.SelectedItem().(sectionHeaderItem); !isHeader </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                <span class="cov0" title="0">m.projectsList.CursorDown()</span>
                        }

                        // Update selectedProject to match
                        <span class="cov8" title="1">oldProject := m.selectedProject
                        m.selectedProject = m.listIndexToProjectIndex(m.projectsList.Index())

                        // If project changed, update services display immediately
                        if oldProject != m.selectedProject </span><span class="cov8" title="1">{
                                m.switchToCurrentProject()
                                return m.pollServicesCmd()
                        }</span>
                }
        case PaneServices:<span class="cov0" title="0">
                if m.selectedService &lt; len(m.services)-1 </span><span class="cov0" title="0">{
                        m.selectedService++
                        m.servicesTable.SetCursor(m.selectedService)
                }</span>
        case PaneLogs:<span class="cov0" title="0">
                m.logView.ScrollDown()</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// View renders the model.
func (m *Model) View() string <span class="cov8" title="1">{
        if m.width == 0 || m.height == 0 </span><span class="cov8" title="1">{
                return "Loading..."
        }</span>

        // Splash screen
        <span class="cov8" title="1">if m.showSplash </span><span class="cov8" title="1">{
                return m.splash.View()
        }</span>

        // Main view
        <span class="cov8" title="1">header := m.renderHeader()
        body := m.renderBody()
        footer := m.renderFooter()

        main := lipgloss.JoinVertical(lipgloss.Left, header, body, footer)

        // Settings modal overlay (centered on screen)
        if m.showSettings </span><span class="cov0" title="0">{
                settingsModal := m.settings.View()
                // Place modal centered on a dark background
                main = lipgloss.Place(
                        m.width,
                        m.height,
                        lipgloss.Center,
                        lipgloss.Center,
                        settingsModal,
                        lipgloss.WithWhitespaceChars(" "),
                        lipgloss.WithWhitespaceForeground(lipgloss.Color("#1a1a1a")),
                )
        }</span>

        // Help modal overlay (centered on screen)
        <span class="cov8" title="1">if m.showHelp </span><span class="cov8" title="1">{
                helpModal := m.helpPanel.View()
                // Place modal centered on a dark background
                main = lipgloss.Place(
                        m.width,
                        m.height,
                        lipgloss.Center,
                        lipgloss.Center,
                        helpModal,
                        lipgloss.WithWhitespaceChars(" "),
                        lipgloss.WithWhitespaceForeground(lipgloss.Color("#1a1a1a")),
                )
        }</span>

        // Alerts modal overlay (centered on screen)
        <span class="cov8" title="1">if m.alertsPanel.IsVisible() </span><span class="cov8" title="1">{
                alertsModal := m.alertsPanel.View()
                // Place modal centered on a dark background
                main = lipgloss.Place(
                        m.width,
                        m.height,
                        lipgloss.Center,
                        lipgloss.Center,
                        alertsModal,
                        lipgloss.WithWhitespaceChars(" "),
                        lipgloss.WithWhitespaceForeground(lipgloss.Color("#1a1a1a")),
                )
        }</span>

        // Confirm dialog overlay (centered, transparent background)
        <span class="cov8" title="1">if m.confirm.IsVisible() </span><span class="cov0" title="0">{
                confirmModal := m.confirm.View()
                // Place modal centered - background shows through
                main = lipgloss.Place(
                        m.width,
                        m.height,
                        lipgloss.Center,
                        lipgloss.Center,
                        confirmModal,
                )
        }</span>

        <span class="cov8" title="1">return main</span>
}

func (m *Model) renderHeader() string <span class="cov8" title="1">{
        title := m.styles.Title.Render("devdash")
        breadcrumb := m.styles.Breadcrumb.Render(" ─── FLEET")

        if p := m.currentProject(); p != nil </span><span class="cov8" title="1">{
                breadcrumb = m.styles.Breadcrumb.Render(fmt.Sprintf(" ─── %s", p.Name))
        }</span>

        // Build stats
        <span class="cov8" title="1">activeCount := 0
        for _, svc := range m.services </span><span class="cov0" title="0">{
                if svc.IsRunning </span><span class="cov0" title="0">{
                        activeCount++
                }</span>
        }
        <span class="cov8" title="1">stats := fmt.Sprintf("Services: %d/%d ── Nix: OK", activeCount, len(m.services))
        statsView := m.styles.StatusBar.Render(stats)

        left := title + breadcrumb

        // Add toast to header if visible
        right := statsView
        if m.toast.IsVisible() </span><span class="cov0" title="0">{
                toast := m.toast.View()
                // Toast replaces stats when visible
                right = toast
        }</span>

        <span class="cov8" title="1">gap := m.width - lipgloss.Width(left) - lipgloss.Width(right) - 2
        if gap &lt; 0 </span><span class="cov0" title="0">{
                gap = 0
        }</span>

        <span class="cov8" title="1">return m.styles.Header.Width(m.width).Render(
                left + fmt.Sprintf("%*s", gap, "") + right,
        )</span>
}

func (m *Model) renderBody() string <span class="cov8" title="1">{
        sidebarWidth := m.config.UI.SidebarWidth
        mainWidth := m.width - sidebarWidth - 4
        bodyHeight := m.height - 4 // header + footer

        sidebar := m.renderSidebar(sidebarWidth, bodyHeight)
        main := m.renderMain(mainWidth, bodyHeight)

        return lipgloss.JoinHorizontal(lipgloss.Top, sidebar, main)
}</span>

func (m *Model) renderSidebar(width, height int) string <span class="cov8" title="1">{
        // Title line
        titleLine := m.renderSectionTitle("PROJECTS", m.focused == PaneSidebar, width-4)

        // Custom filter UI
        var filterLine string
        listHeight := height  // Use full height - let border handle spacing
        if m.projectFilterMode || m.projectFilterInput != "" </span><span class="cov0" title="0">{
                filterPromptStyle := lipgloss.NewStyle().
                        Foreground(m.styles.theme.Primary).
                        Bold(true)
                filterInputStyle := lipgloss.NewStyle().
                        Foreground(m.styles.theme.Primary)

                if m.projectFilterMode </span><span class="cov0" title="0">{
                        // Show cursor when in input mode
                        filterLine = filterPromptStyle.Render("Filter: ") + filterInputStyle.Render(m.projectFilterInput+"_")
                }</span> else<span class="cov0" title="0"> {
                        // Show filter without cursor when applied but not in input mode
                        filterLine = filterPromptStyle.Render("Filter: ") + filterInputStyle.Render(m.projectFilterInput)
                }</span>
                <span class="cov0" title="0">listHeight = height - 1</span> // Just reduce by filter line
        }

        // Update list size and render
        <span class="cov8" title="1">m.projectsList.SetSize(width-4, listHeight)
        listView := m.projectsList.View()

        // Aggressively remove leading blank lines by splitting and rejoining
        lines := strings.Split(listView, "\n")
        // Skip leading empty lines
        for len(lines) &gt; 0 &amp;&amp; strings.TrimSpace(lines[0]) == "" </span><span class="cov8" title="1">{
                lines = lines[1:]
        }</span>
        <span class="cov8" title="1">listView = strings.Join(lines, "\n")

        // Build content - minimal gaps
        content := titleLine + "\n" + listView
        if filterLine != "" </span><span class="cov0" title="0">{
                content = titleLine + "\n" + filterLine + "\n" + listView
        }</span>

        <span class="cov8" title="1">style := m.styles.BlurredBorder
        if m.focused == PaneSidebar </span><span class="cov8" title="1">{
                style = m.styles.FocusedBorder
        }</span>

        <span class="cov8" title="1">return style.Width(width).Height(height).Render(content)</span>
}

func (m *Model) renderProjectItem(idx int, p *registry.Project) string <span class="cov0" title="0">{
        // Use cached state for consistent rendering
        state := m.projectStates[p.Path]
        var glyph string

        // Show spinner if this project is currently loading
        if m.loadingProject == p.Name &amp;&amp; m.loadingOp != "" </span><span class="cov0" title="0">{
                glyph = m.spinner.View()
        }</span> else<span class="cov0" title="0"> {
                switch state </span>{
                case registry.StateRunning:<span class="cov0" title="0">
                        glyph = m.styles.StatusRunning.Render("●")</span>
                case registry.StateDegraded:<span class="cov0" title="0">
                        glyph = m.styles.StatusDegraded.Render("◐")</span>
                case registry.StateIdle:<span class="cov0" title="0">
                        glyph = m.styles.StatusIdle.Render("○")</span>
                case registry.StateStale:<span class="cov0" title="0">
                        glyph = m.styles.StatusStale.Render("✗")</span>
                case registry.StateMissing:<span class="cov0" title="0">
                        glyph = m.styles.StatusMissing.Render("✗")</span>
                }
        }

        <span class="cov0" title="0">name := p.Name

        // Add hidden icon if project is hidden
        if p.Hidden </span><span class="cov0" title="0">{
                name = name + " ■"
        }</span>

        <span class="cov0" title="0">cursor := "  " // No cursor
        if idx == m.selectedProject </span><span class="cov0" title="0">{
                cursor = "&gt; " // Selection cursor
                if m.focused == PaneSidebar </span><span class="cov0" title="0">{
                        if p.Hidden </span><span class="cov0" title="0">{
                                // Hidden project selected - dimmed even when focused
                                name = m.styles.Breadcrumb.Render(name)
                        }</span> else<span class="cov0" title="0"> {
                                name = m.styles.SelectedItem.Render(name)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Dimmed selection when not focused
                        name = m.styles.Breadcrumb.Render(name)
                }</span>
        } else<span class="cov0" title="0"> {
                if p.Hidden </span><span class="cov0" title="0">{
                        // Hidden project not selected - extra dimmed
                        name = m.styles.Breadcrumb.Render(name)
                }</span> else<span class="cov0" title="0"> {
                        name = m.styles.ProjectItem.Render(name)
                }</span>
        }

        <span class="cov0" title="0">return fmt.Sprintf("%s%s %s", cursor, glyph, name)</span>
}

func (m *Model) renderMain(width, height int) string <span class="cov8" title="1">{
        // Determine layout based on width
        if m.shouldShowBothPanes() </span><span class="cov8" title="1">{
                // Wide terminal: show Services, Packages, and Logs stacked vertically
                servicesHeight := height / 4
                packagesHeight := height / 4
                logsHeight := height - servicesHeight - packagesHeight - 4

                services := m.renderServices(width, servicesHeight)
                packages := m.renderPackages(width, packagesHeight)
                logs := m.renderLogs(width, logsHeight)

                return lipgloss.JoinVertical(lipgloss.Left, services, packages, logs)
        }</span> else<span class="cov8" title="1"> {
                // Narrow terminal: show either Services or Packages, plus Logs
                mainPaneHeight := height / 3
                logsHeight := height - mainPaneHeight - 2

                var mainPane string
                if m.showPackages </span><span class="cov8" title="1">{
                        mainPane = m.renderPackages(width, mainPaneHeight)
                }</span> else<span class="cov8" title="1"> {
                        mainPane = m.renderServices(width, mainPaneHeight)
                }</span>

                <span class="cov8" title="1">logs := m.renderLogs(width, logsHeight)

                return lipgloss.JoinVertical(lipgloss.Left, mainPane, logs)</span>
        }
}

func (m *Model) renderServices(width, height int) string <span class="cov8" title="1">{
        var content string

        if p := m.currentProject(); p != nil </span><span class="cov8" title="1">{
                // Title with focus indicator and toggle hint on narrow terminals
                title := fmt.Sprintf("SERVICES [%s]", p.Name)
                if !m.shouldShowBothPanes() </span><span class="cov8" title="1">{
                        title += " [p:packages]"
                }</span>
                <span class="cov8" title="1">content = m.renderSectionTitle(title, m.focused == PaneServices, width-4) + "\n"

                if len(m.services) == 0 </span><span class="cov8" title="1">{
                        // Enhanced empty state with better visual hierarchy
                        emptyStateHeight := height - 8
                        emptyContent := m.renderEmptyState(
                                "No Services Running",
                                []string{
                                        "This project has no active services",
                                        "",
                                        "Press 's' to start the project",
                                        "Press '?' for more commands",
                                },
                                width-6,
                                emptyStateHeight,
                        )
                        content += emptyContent
                }</span> else<span class="cov0" title="0"> {
                        // Update table focus based on pane focus
                        m.servicesTable.SetHeight(height - 6)
                        if m.focused == PaneServices </span><span class="cov0" title="0">{
                                m.servicesTable.Focus()
                        }</span> else<span class="cov0" title="0"> {
                                m.servicesTable.Blur()
                        }</span>

                        // Render the table
                        <span class="cov0" title="0">content += m.servicesTable.View()</span>
                }
        } else<span class="cov8" title="1"> {
                title := "SERVICES"
                if !m.shouldShowBothPanes() </span><span class="cov8" title="1">{
                        title += " [p:packages]"
                }</span>
                <span class="cov8" title="1">content = m.renderSectionTitle(title, m.focused == PaneServices, width-4) + "\n"
                emptyStateHeight := height - 8
                emptyContent := m.renderEmptyState(
                        "No Project Selected",
                        []string{
                                "Select a project from the sidebar",
                                "to view its services",
                                "",
                                "Use ↑/↓ or Tab to navigate",
                        },
                        width-6,
                        emptyStateHeight,
                )
                content += emptyContent</span>
        }

        <span class="cov8" title="1">style := m.styles.BlurredBorder
        if m.focused == PaneServices </span><span class="cov0" title="0">{
                style = m.styles.FocusedBorder
        }</span>

        <span class="cov8" title="1">return style.Width(width).Height(height).Render(content)</span>
}

func (m *Model) renderPackages(width, height int) string <span class="cov8" title="1">{
        // Update packagesView size and focus state
        m.packagesView.SetSize(width-4, height-4)
        m.packagesView.SetFocused(m.focused == PanePackages)

        // Add toggle indicator on narrow terminals
        if !m.shouldShowBothPanes() </span><span class="cov8" title="1">{
                m.packagesView.SetTitleSuffix("[p:services]")
        }</span> else<span class="cov8" title="1"> {
                m.packagesView.SetTitleSuffix("")
        }</span>

        // Get packages view content
        <span class="cov8" title="1">packagesContent := m.packagesView.View()

        // Wrap in border
        style := m.styles.BlurredBorder
        if m.focused == PanePackages </span><span class="cov0" title="0">{
                style = m.styles.FocusedBorder
        }</span>

        <span class="cov8" title="1">return style.Width(width).Height(height).Render(packagesContent)</span>
}

func (m *Model) renderLogs(width, height int) string <span class="cov8" title="1">{
        m.logView.SetSize(width-4, height-4)

        // Title with focus indicator
        title := "LOGS"
        content := m.renderSectionTitle(title, m.focused == PaneLogs, width-4) + "\n"

        // Build status line with filters
        var statusParts []string

        // Show service filter if active
        if svc := m.logView.GetService(); svc != "" </span><span class="cov0" title="0">{
                statusParts = append(statusParts, fmt.Sprintf("[%s]", svc))
        }</span> else<span class="cov8" title="1"> {
                statusParts = append(statusParts, "[ALL]")
        }</span>

        <span class="cov8" title="1">if m.logView.IsFollowing() </span><span class="cov8" title="1">{
                statusParts = append(statusParts, "[FOLLOW]")
        }</span>

        // Show scroll position
        <span class="cov8" title="1">current, total := m.logView.ScrollInfo()
        if total &gt; 0 </span><span class="cov0" title="0">{
                statusParts = append(statusParts, fmt.Sprintf("%d/%d", current, total))
        }</span>

        // Show search info
        <span class="cov8" title="1">if m.searchMode </span><span class="cov0" title="0">{
                // Active input mode - show textinput with cursor
                statusParts = append(statusParts, m.searchInput.View())
        }</span> else<span class="cov8" title="1"> if m.logView.IsSearchActive() </span><span class="cov0" title="0">{
                // Search active but not in input mode
                matchInfo := ""
                if m.logView.MatchCount() &gt; 0 </span><span class="cov0" title="0">{
                        matchInfo = fmt.Sprintf(" %d/%d", m.logView.CurrentMatchIndex(), m.logView.MatchCount())
                }</span> else<span class="cov0" title="0"> {
                        matchInfo = " (no matches)"
                }</span>
                <span class="cov0" title="0">searchTerm := m.searchInput.Value()
                if m.logView.IsFilterMode() </span><span class="cov0" title="0">{
                        statusParts = append(statusParts, fmt.Sprintf("[FILTER: %s]%s", searchTerm, matchInfo))
                }</span> else<span class="cov0" title="0"> {
                        statusParts = append(statusParts, fmt.Sprintf("[SEARCH: %s]%s", searchTerm, matchInfo))
                }</span>
        }

        // Combine status parts
        <span class="cov8" title="1">if len(statusParts) &gt; 0 </span><span class="cov8" title="1">{
                content += m.styles.Breadcrumb.Render(strings.Join(statusParts, " ")) + "\n"
        }</span> else<span class="cov0" title="0"> {
                content += "\n"
        }</span>

        <span class="cov8" title="1">if m.logView.buffer.Len() == 0 </span><span class="cov8" title="1">{
                content += m.styles.Breadcrumb.Render("No logs yet - logs will appear when services run")
        }</span> else<span class="cov0" title="0"> {
                content += m.logView.View()
        }</span>

        <span class="cov8" title="1">style := m.styles.BlurredBorder
        if m.focused == PaneLogs </span><span class="cov0" title="0">{
                style = m.styles.FocusedBorder
        }</span>

        <span class="cov8" title="1">return style.Width(width).Height(height).Render(content)</span>
}

// highlightKeys highlights keybinds in brackets with theme colors
func (m *Model) highlightKeys(text string) string <span class="cov8" title="1">{
        // Simple approach: highlight text within brackets
        result := ""
        inBracket := false
        bracketContent := ""

        for _, ch := range text </span><span class="cov8" title="1">{
                if ch == '[' </span><span class="cov8" title="1">{
                        inBracket = true
                        bracketContent = ""
                        result += lipgloss.NewStyle().Foreground(m.styles.theme.Muted).Render("[")
                }</span> else<span class="cov8" title="1"> if ch == ']' </span><span class="cov8" title="1">{
                        inBracket = false
                        result += lipgloss.NewStyle().
                                Foreground(m.styles.theme.Primary).
                                Bold(true).
                                Render(bracketContent)
                        result += lipgloss.NewStyle().Foreground(m.styles.theme.Muted).Render("]")
                }</span> else<span class="cov8" title="1"> if inBracket </span><span class="cov8" title="1">{
                        bracketContent += string(ch)
                }</span> else<span class="cov8" title="1"> {
                        result += string(ch)
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// updateServicesTable updates the table rows from the services list.
func (m *Model) updateServicesTable() <span class="cov0" title="0">{
        rows := make([]table.Row, len(m.services))
        for i, svc := range m.services </span><span class="cov0" title="0">{
                var status string
                if svc.IsRunning </span><span class="cov0" title="0">{
                        status = "Running"
                }</span> else<span class="cov0" title="0"> {
                        status = "Stopped"
                }</span>

                // Simple values - let table component handle width and padding
                <span class="cov0" title="0">pid := "-"
                if svc.Pid &gt; 0 </span><span class="cov0" title="0">{
                        pid = fmt.Sprintf("%d", svc.Pid)
                }</span>

                <span class="cov0" title="0">cpu := "-"
                if svc.IsRunning </span><span class="cov0" title="0">{
                        cpu = fmt.Sprintf("%.1f%%", svc.CPU)
                }</span>

                <span class="cov0" title="0">mem := "-"
                if svc.IsRunning &amp;&amp; svc.Mem &gt; 0 </span><span class="cov0" title="0">{
                        mem = formatBytes(svc.Mem)
                }</span>

                <span class="cov0" title="0">uptimeOrExit := "-"
                if svc.IsRunning &amp;&amp; svc.SystemTime != "" </span><span class="cov0" title="0">{
                        uptimeOrExit = formatSystemTime(svc.SystemTime)
                }</span> else<span class="cov0" title="0"> if svc.ExitCode != 0 </span><span class="cov0" title="0">{
                        uptimeOrExit = fmt.Sprintf("exit %d", svc.ExitCode)
                }</span>

                // Apply flash effect to status if state recently changed
                <span class="cov0" title="0">styledStatus := m.applyFlashEffect(status, svc.Name, svc.IsRunning)

                // Get activity indicator (animated spinner if logs received recently)
                activity := m.getActivityIndicator(svc.Name)

                // Combine status and activity
                statusWithActivity := styledStatus + " " + activity

                // Simple row - table handles all width management
                rows[i] = table.Row{
                        statusWithActivity,
                        svc.Name,
                        pid,
                        cpu,
                        mem,
                        uptimeOrExit,
                }</span>
        }
        <span class="cov0" title="0">m.servicesTable.SetRows(rows)</span>
}

// applyFlashEffect applies a pulse/flash animation to status text after state changes.
// Returns the status text with styling applied based on current flash intensity.
func (m *Model) applyFlashEffect(status string, serviceName string, isRunning bool) string <span class="cov0" title="0">{
        intensity, hasFlash := m.stateFlashIntensity[serviceName]
        if !hasFlash || intensity &lt;= 0 </span><span class="cov0" title="0">{
                // No flash, return plain status
                return status
        }</span>

        // Choose color based on service state
        <span class="cov0" title="0">var baseColor lipgloss.Color
        if isRunning </span><span class="cov0" title="0">{
                baseColor = m.styles.theme.Success // Green for running
        }</span> else<span class="cov0" title="0"> {
                baseColor = m.styles.theme.Warning // Yellow/orange for stopped
        }</span>

        // Apply flash styling: bold and use primary color mixed with base color
        // As intensity decreases, color transitions from bright primary to normal base color
        <span class="cov0" title="0">flashStyle := lipgloss.NewStyle().
                Bold(true).
                Foreground(baseColor)

        return flashStyle.Render(status)</span>
}

// getActivityIndicator returns the activity indicator for a service.
// Shows animated braille spinner if logs received within last 2 seconds, otherwise empty.
func (m *Model) getActivityIndicator(serviceName string) string <span class="cov0" title="0">{
        // Braille spinner frames (8 frames for smooth animation)
        frames := []string{"⣾", "⣽", "⣻", "⢿", "⡿", "⣟", "⣯", "⣷"}

        lastActivity, exists := m.logActivity[serviceName]
        if !exists </span><span class="cov0" title="0">{
                return " " // No activity yet
        }</span>

        // Show spinner if activity within last 2 seconds
        <span class="cov0" title="0">if time.Since(lastActivity) &lt; 2*time.Second </span><span class="cov0" title="0">{
                frameIndex := m.activityFrame % len(frames)
                return frames[frameIndex]
        }</span>

        <span class="cov0" title="0">return " "</span> // Activity too old, show nothing
}

// renderSparkline generates a sparkline from a slice of values using Unicode block characters.
// Returns a string like "▁▂▃▄▅▆▇█" representing the trend.
func renderSparkline(values []float64) string <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Unicode block characters from empty to full
        <span class="cov0" title="0">blocks := []rune{'▁', '▂', '▃', '▄', '▅', '▆', '▇', '█'}

        // Find min and max for normalization
        min, max := values[0], values[0]
        for _, v := range values </span><span class="cov0" title="0">{
                if v &lt; min </span><span class="cov0" title="0">{
                        min = v
                }</span>
                <span class="cov0" title="0">if v &gt; max </span><span class="cov0" title="0">{
                        max = v
                }</span>
        }

        // Avoid division by zero
        <span class="cov0" title="0">if max == min </span><span class="cov0" title="0">{
                // All values the same, use mid-level block
                result := make([]rune, len(values))
                for i := range result </span><span class="cov0" title="0">{
                        result[i] = blocks[3]
                }</span>
                <span class="cov0" title="0">return string(result)</span>
        }

        // Normalize and map to blocks
        <span class="cov0" title="0">result := make([]rune, len(values))
        for i, v := range values </span><span class="cov0" title="0">{
                normalized := (v - min) / (max - min) // 0.0 to 1.0
                blockIndex := int(normalized * float64(len(blocks)-1))
                if blockIndex &gt;= len(blocks) </span><span class="cov0" title="0">{
                        blockIndex = len(blocks) - 1
                }</span>
                <span class="cov0" title="0">result[i] = blocks[blockIndex]</span>
        }

        <span class="cov0" title="0">return string(result)</span>
}

// renderMemorySparkline generates a sparkline from memory values (int64).
func renderMemorySparkline(values []int64) string <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Convert to float64 for rendering
        <span class="cov0" title="0">floatValues := make([]float64, len(values))
        for i, v := range values </span><span class="cov0" title="0">{
                floatValues[i] = float64(v)
        }</span>

        <span class="cov0" title="0">return renderSparkline(floatValues)</span>
}

// renderCompactProgress renders a compact progress indicator for the sidebar.
// Example output: "devdash [████░░] Starting..."
func (m *Model) renderCompactProgress(progress float64, stage string) string <span class="cov0" title="0">{
        // Get current project name
        projectName := m.loadingProject
        if p := m.currentProject(); p != nil &amp;&amp; p.Name == m.loadingProject </span><span class="cov0" title="0">{
                projectName = p.Name
        }</span>

        // Compact bar - just 6 chars
        <span class="cov0" title="0">barWidth := 6
        filledWidth := int(float64(barWidth) * progress)
        if filledWidth &gt; barWidth </span><span class="cov0" title="0">{
                filledWidth = barWidth
        }</span>

        // Get theme colors
        <span class="cov0" title="0">primaryHex := string(m.styles.theme.Primary)
        secondaryHex := string(m.styles.theme.Secondary)
        mutedHex := string(m.styles.theme.Muted)

        // Parse colors
        primaryCol, _ := colorful.Hex(primaryHex)
        secondaryCol, _ := colorful.Hex(secondaryHex)

        // Build mini gradient bar
        var bar strings.Builder
        bar.WriteString("[")

        for i := 0; i &lt; barWidth; i++ </span><span class="cov0" title="0">{
                if i &lt; filledWidth </span><span class="cov0" title="0">{
                        var gradientPos float64
                        if filledWidth &gt; 1 </span><span class="cov0" title="0">{
                                gradientPos = float64(i) / float64(filledWidth-1)
                        }</span>
                        <span class="cov0" title="0">blendedColor := primaryCol.BlendLuv(secondaryCol, gradientPos)
                        charStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(blendedColor.Hex()))
                        bar.WriteString(charStyle.Render("█"))</span>
                } else<span class="cov0" title="0"> {
                        emptyStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(mutedHex))
                        bar.WriteString(emptyStyle.Render("░"))
                }</span>
        }
        <span class="cov0" title="0">bar.WriteString("]")

        // Compact stage text - just the first word or shortened version
        compactStage := stage
        if len(stage) &gt; 12 </span><span class="cov0" title="0">{
                compactStage = stage[:12] + "..."
        }</span>

        // Build: "projectName [bar] stage"
        <span class="cov0" title="0">nameStyle := m.styles.SelectedItem
        stageStyle := lipgloss.NewStyle().Foreground(m.styles.theme.Muted)

        return nameStyle.Render(projectName) + " " + bar.String() + " " + stageStyle.Render(compactStage)</span>
}

// renderProgressBar renders a progress bar with percentage and stage description.
// Example output: "[██████░░░░] 60% Starting services..."
func (m *Model) renderProgressBar(progress float64, stage string, width int) string <span class="cov0" title="0">{
        if width &lt; 20 </span><span class="cov0" title="0">{
                width = 20 // Minimum width
        }</span>

        // Calculate bar width (reserve space for brackets, percentage, and stage)
        // Format: "[bar] xx% stage"
        <span class="cov0" title="0">barWidth := 10 // Fixed bar width for consistency
        percentage := int(progress * 100)

        // Build the bar using block characters with gradient
        filledWidth := int(float64(barWidth) * progress)
        if filledWidth &gt; barWidth </span><span class="cov0" title="0">{
                filledWidth = barWidth
        }</span>

        // Get theme colors for gradient
        <span class="cov0" title="0">primaryHex := string(m.styles.theme.Primary)
        secondaryHex := string(m.styles.theme.Secondary)
        mutedHex := string(m.styles.theme.Muted)

        // Parse colors for gradient blending
        primaryCol, _ := colorful.Hex(primaryHex)
        secondaryCol, _ := colorful.Hex(secondaryHex)

        // Build gradient bar
        var result strings.Builder
        result.WriteString("[")

        for i := 0; i &lt; barWidth; i++ </span><span class="cov0" title="0">{
                if i &lt; filledWidth </span><span class="cov0" title="0">{
                        // Calculate gradient position
                        var gradientPos float64
                        if filledWidth &gt; 1 </span><span class="cov0" title="0">{
                                gradientPos = float64(i) / float64(filledWidth-1)
                        }</span>
                        <span class="cov0" title="0">blendedColor := primaryCol.BlendLuv(secondaryCol, gradientPos)
                        charStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(blendedColor.Hex()))
                        result.WriteString(charStyle.Render("█"))</span>
                } else<span class="cov0" title="0"> {
                        emptyStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(mutedHex))
                        result.WriteString(emptyStyle.Render("░"))
                }</span>
        }

        <span class="cov0" title="0">result.WriteString("] ")
        result.WriteString(fmt.Sprintf("%2d%% ", percentage))

        // Stage text in muted color
        stageStyle := lipgloss.NewStyle().Foreground(m.styles.theme.Muted)
        result.WriteString(stageStyle.Render(stage))

        return result.String()</span>
}

// renderEmptyState renders a centered empty state message.
func (m *Model) renderEmptyState(title string, lines []string, width, height int) string <span class="cov8" title="1">{
        var content []string

        // Title in primary color
        titleStyle := lipgloss.NewStyle().
                Foreground(m.styles.theme.Primary).
                Bold(true)
        content = append(content, titleStyle.Render(title))
        content = append(content, "")

        // Message lines in muted color
        messageStyle := lipgloss.NewStyle().
                Foreground(m.styles.theme.Muted)

        for _, line := range lines </span><span class="cov8" title="1">{
                if line == "" </span><span class="cov8" title="1">{
                        content = append(content, "")
                }</span> else<span class="cov8" title="1"> {
                        content = append(content, messageStyle.Render(line))
                }</span>
        }

        // Join all lines
        <span class="cov8" title="1">joined := lipgloss.JoinVertical(lipgloss.Left, content...)

        // Center the content
        return lipgloss.Place(
                width,
                height,
                lipgloss.Center,
                lipgloss.Center,
                joined,
        )</span>
}

// renderSectionTitle renders a section title in code comment style with separator line.
// Uses primary color if focused, muted color otherwise.
func (m *Model) renderSectionTitle(title string, focused bool, width int) string <span class="cov8" title="1">{
        // Calculate separator line length
        // Format: "// " (3) + title + " " (1) + separator
        // We want the line to extend close to the edge
        separatorLen := width - len(title) - 4 + 4 // +4 to extend closer to edge
        if separatorLen &lt; 0 </span><span class="cov0" title="0">{
                separatorLen = 0
        }</span>
        <span class="cov8" title="1">separator := strings.Repeat("─", separatorLen)

        var style lipgloss.Style
        if focused </span><span class="cov8" title="1">{
                style = lipgloss.NewStyle().
                        Foreground(m.styles.theme.Primary).
                        Bold(true)
        }</span> else<span class="cov8" title="1"> {
                style = lipgloss.NewStyle().
                        Foreground(m.styles.theme.Muted)
        }</span>

        <span class="cov8" title="1">return style.Render("// " + title + " " + separator)</span>
}

func (m *Model) renderFooter() string <span class="cov8" title="1">{
        var help string
        switch m.focused </span>{
        case PaneSidebar:<span class="cov8" title="1">
                // Check if current project is stale to show repair option
                isStale := false
                if p := m.currentProject(); p != nil </span><span class="cov8" title="1">{
                        state := p.DetectState()
                        isStale = (state == registry.StateStale)
                }</span>
                <span class="cov8" title="1">if isStale </span><span class="cov0" title="0">{
                        help = "[↑/↓] Navigate  [Tab] Switch Pane  [c] Repair  [d] Delete  [Ctrl+h] Hide  [?] Help"
                }</span> else<span class="cov8" title="1"> {
                        help = "[↑/↓] Navigate  [Tab] Switch Pane  [/] Search  [Enter] Select  [s] Start  [x] Stop  [d] Delete  [Ctrl+h] Hide  [?] Help"
                }</span>
        case PaneServices:<span class="cov0" title="0">
                help = "[↑/↓] Navigate  [Tab] Switch Pane  [Enter] Filter  [s] Start  [x] Stop  [r] Restart  [?] Help"</span>
        case PaneLogs:<span class="cov0" title="0">
                if m.searchMode </span><span class="cov0" title="0">{
                        help = "[Type] Search  [Enter] Confirm  [Esc] Cancel"
                }</span> else<span class="cov0" title="0"> if m.logView.IsSearchActive() </span><span class="cov0" title="0">{
                        help = "[n/N] Next/Prev  [Ctrl+f] Filter  [/] New Search  [Esc] Clear  [?] Help"
                }</span> else<span class="cov0" title="0"> {
                        help = "[↑/↓] Scroll  [Tab] Switch Pane  [f] Follow  [/] Search  [g/G] Top/Bottom  [?] Help"
                }</span>
        }

        // Highlight the keybinds
        <span class="cov8" title="1">highlightedHelp := m.highlightKeys(help)
        return lipgloss.NewStyle().
                Width(m.width).
                Align(lipgloss.Center).
                Render(highlightedHelp)</span>
}

// formatBytes converts bytes to human-readable format (KB, MB, GB).
func formatBytes(bytes int64) string <span class="cov8" title="1">{
        const (
                KB = 1024
                MB = KB * 1024
                GB = MB * 1024
        )

        switch </span>{
        case bytes &gt;= GB:<span class="cov8" title="1">
                return fmt.Sprintf("%.1fG", float64(bytes)/GB)</span>
        case bytes &gt;= MB:<span class="cov8" title="1">
                return fmt.Sprintf("%.1fM", float64(bytes)/MB)</span>
        case bytes &gt;= KB:<span class="cov8" title="1">
                return fmt.Sprintf("%.0fK", float64(bytes)/KB)</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("%dB", bytes)</span>
        }
}

// formatDuration formats a duration in a compact human-readable form.
func formatDuration(d time.Duration) string <span class="cov8" title="1">{
        if d &lt; time.Minute </span><span class="cov8" title="1">{
                return fmt.Sprintf("%ds", int(d.Seconds()))
        }</span>
        <span class="cov8" title="1">if d &lt; time.Hour </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dm", int(d.Minutes()))
        }</span>
        <span class="cov8" title="1">if d &lt; 24*time.Hour </span><span class="cov8" title="1">{
                hours := int(d.Hours())
                mins := int(d.Minutes()) % 60
                if mins &gt; 0 </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%dh%dm", hours, mins)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("%dh", hours)</span>
        }
        <span class="cov8" title="1">days := int(d.Hours()) / 24
        hours := int(d.Hours()) % 24
        if hours &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dd%dh", days, hours)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%dd", days)</span>
}

// formatSystemTime formats the system_time string from process-compose API.
// The API returns time in format like "1h2m3s" or "2m30.5s".
func formatSystemTime(sysTime string) string <span class="cov8" title="1">{
        // Try to parse as Go duration
        d, err := time.ParseDuration(sysTime)
        if err != nil </span><span class="cov8" title="1">{
                // If parsing fails, return as-is but truncated
                if len(sysTime) &gt; 8 </span><span class="cov0" title="0">{
                        return sysTime[:8]
                }</span>
                <span class="cov8" title="1">return sysTime</span>
        }
        <span class="cov8" title="1">return formatDuration(d)</span>
}

// projectDelegate is a custom list delegate for rendering projects.
type projectDelegate struct {
        styles *Styles
        model  *Model // Reference to parent model for spinner/loading state
}

// NewProjectDelegate creates a new project delegate.
func NewProjectDelegate(styles *Styles, model *Model) list.ItemDelegate <span class="cov8" title="1">{
        return &amp;projectDelegate{styles: styles, model: model}
}</span>

func (d *projectDelegate) Height() int <span class="cov8" title="1">{ return 1 }</span>
func (d *projectDelegate) Spacing() int <span class="cov8" title="1">{
        // Subtle spacing between project items for better readability
        return 0 // Keep at 0 for now - spacing makes list too sparse in sidebar
}</span>
func (d *projectDelegate) Update(msg tea.Msg, m *list.Model) tea.Cmd <span class="cov8" title="1">{ return nil }</span>

func (d *projectDelegate) Render(w io.Writer, m list.Model, index int, item list.Item) <span class="cov8" title="1">{
        // Check if this is a section header
        if headerItem, ok := item.(sectionHeaderItem); ok </span><span class="cov8" title="1">{
                headerStyle := lipgloss.NewStyle().
                        Foreground(d.styles.theme.Muted).
                        Bold(true)
                // Enhanced visual separator with subtle styling
                separator := lipgloss.NewStyle().Foreground(d.styles.theme.Muted).Render("─")
                fmt.Fprintf(w, " %s %s", headerStyle.Render(headerItem.title), separator)
                return
        }</span>

        <span class="cov8" title="1">projItem, ok := item.(projectListItem)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        // Get status glyph (or progress indicator if loading)
        <span class="cov8" title="1">var glyph string
        var loadingDisplay string
        if d.model != nil &amp;&amp; d.model.loadingProject == projItem.project.Name &amp;&amp; d.model.loadingOp != "" </span><span class="cov0" title="0">{
                // Show compact progress indicator when this project is loading
                loadingDisplay = d.model.renderCompactProgress(d.model.loadingProgress, d.model.loadingStage)
                glyph = "" // Don't show status glyph during loading
        }</span> else<span class="cov8" title="1"> {
                switch projItem.state </span>{
                case registry.StateRunning:<span class="cov0" title="0">
                        glyph = d.styles.StatusRunning.Render("●")</span>
                case registry.StateDegraded:<span class="cov0" title="0">
                        glyph = d.styles.StatusDegraded.Render("◐")</span>
                case registry.StateIdle:<span class="cov8" title="1">
                        glyph = d.styles.StatusIdle.Render("○")</span>
                case registry.StateStale:<span class="cov0" title="0">
                        glyph = d.styles.StatusStale.Render("✗")</span>
                case registry.StateMissing:<span class="cov0" title="0">
                        glyph = d.styles.StatusMissing.Render("✗")</span>
                }
        }

        <span class="cov8" title="1">name := projItem.project.Name
        if projItem.project.Hidden </span><span class="cov0" title="0">{
                name = name + " ■"
        }</span>

        // Check if selected - use our model's selection state for consistency
        // This avoids potential flicker from list component's internal state
        <span class="cov8" title="1">isSelected := false
        if d.model != nil </span><span class="cov8" title="1">{
                expectedListIndex := d.model.projectIndexToListIndex(d.model.selectedProject)
                isSelected = index == expectedListIndex
        }</span> else<span class="cov0" title="0"> {
                // Fallback to list's index if model not set
                isSelected = index == m.Index()
        }</span>
        <span class="cov8" title="1">cursor := "   "  // Indent project items under section headers
        if isSelected </span><span class="cov8" title="1">{
                cursor = " &gt; "
                name = d.styles.SelectedItem.Render(name)
        }</span> else<span class="cov0" title="0"> {
                if projItem.project.Hidden </span><span class="cov0" title="0">{
                        name = d.styles.Breadcrumb.Render(name)
                }</span> else<span class="cov0" title="0"> {
                        name = d.styles.ProjectItem.Render(name)
                }</span>
        }

        // Show loading indicator during loading, otherwise show normal status + name
        <span class="cov8" title="1">if loadingDisplay != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(w, "%s%s", cursor, loadingDisplay)
        }</span> else<span class="cov8" title="1"> {
                fmt.Fprintf(w, "%s%s %s", cursor, glyph, name)
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package ui

import (
        "fmt"

        "github.com/charmbracelet/lipgloss"
        "github.com/infktd/devdash/internal/packages"
)

// PackagesView displays installed packages for a project.
type PackagesView struct {
        styles      *Styles
        packages    []packages.Package
        width       int
        height      int
        focused     bool
        titleSuffix string // Optional suffix to append to title (e.g., "[p:services]")
}

// NewPackagesView creates a new packages view.
func NewPackagesView(styles *Styles) *PackagesView <span class="cov8" title="1">{
        return &amp;PackagesView{
                styles:   styles,
                packages: []packages.Package{},
                width:    0,
                height:   0,
        }
}</span>

// SetPackages updates the package list.
func (pv *PackagesView) SetPackages(pkgs []packages.Package) <span class="cov8" title="1">{
        pv.packages = pkgs
}</span>

// SetSize updates dimensions.
func (pv *PackagesView) SetSize(width, height int) <span class="cov8" title="1">{
        pv.width = width
        pv.height = height
}</span>

// SetFocused sets focus state.
func (pv *PackagesView) SetFocused(focused bool) <span class="cov8" title="1">{
        pv.focused = focused
}</span>

// SetTitleSuffix sets an optional suffix to append to the title.
func (pv *PackagesView) SetTitleSuffix(suffix string) <span class="cov8" title="1">{
        pv.titleSuffix = suffix
}</span>

// View renders the packages view.
func (pv *PackagesView) View() string <span class="cov8" title="1">{
        if pv.width == 0 || pv.height == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        // Header with focus styling
        <span class="cov8" title="1">title := fmt.Sprintf("PACKAGES (%d)", len(pv.packages))
        if pv.titleSuffix != "" </span><span class="cov8" title="1">{
                title += " " + pv.titleSuffix
        }</span>
        <span class="cov8" title="1">var headerStyle lipgloss.Style
        if pv.focused </span><span class="cov0" title="0">{
                headerStyle = lipgloss.NewStyle().
                        Foreground(pv.styles.theme.Primary).
                        Bold(true)
        }</span> else<span class="cov8" title="1"> {
                headerStyle = lipgloss.NewStyle().
                        Foreground(pv.styles.theme.Muted)
        }</span>
        <span class="cov8" title="1">header := headerStyle.Render(title)

        // Empty state
        if len(pv.packages) == 0 </span><span class="cov8" title="1">{
                emptyMsg := lipgloss.NewStyle().
                        Foreground(pv.styles.theme.Muted).
                        Render("No packages detected")
                content := lipgloss.NewStyle().
                        Width(pv.width).
                        Height(pv.height - 1).
                        Align(lipgloss.Center, lipgloss.Center).
                        Render(emptyMsg)

                return lipgloss.JoinVertical(lipgloss.Left, header, content)
        }</span>

        // Column headers
        <span class="cov8" title="1">colHeaders := pv.renderColumnHeaders()

        // Package rows
        rows := pv.renderPackageRows()

        // Combine
        var lines []string
        lines = append(lines, header)
        lines = append(lines, colHeaders)
        lines = append(lines, rows...)

        return lipgloss.JoinVertical(lipgloss.Left, lines...)</span>
}

// renderColumnHeaders renders the column header row.
func (pv *PackagesView) renderColumnHeaders() string <span class="cov8" title="1">{
        headerStyle := lipgloss.NewStyle().
                Foreground(pv.styles.theme.Muted).
                Bold(true)

        nameCol := headerStyle.Width(20).Render("NAME")
        versionCol := headerStyle.Width(15).Render("VERSION")
        typeCol := headerStyle.Width(15).Render("TYPE")

        return lipgloss.JoinHorizontal(lipgloss.Top, nameCol, versionCol, typeCol)
}</span>

// renderPackageRows renders package data rows.
func (pv *PackagesView) renderPackageRows() []string <span class="cov8" title="1">{
        var rows []string

        // Limit to visible height (header + column headers take 2 lines)
        maxRows := pv.height - 2
        if maxRows &lt; 0 </span><span class="cov0" title="0">{
                maxRows = 0
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; len(pv.packages) &amp;&amp; i &lt; maxRows; i++ </span><span class="cov8" title="1">{
                pkg := pv.packages[i]

                // Truncate long names
                name := pkg.Name
                if len(name) &gt; 18 </span><span class="cov0" title="0">{
                        name = name[:15] + "..."
                }</span>

                <span class="cov8" title="1">version := pkg.Version
                if version == "" </span><span class="cov0" title="0">{
                        version = "unknown"
                }</span>
                <span class="cov8" title="1">if len(version) &gt; 13 </span><span class="cov0" title="0">{
                        version = version[:10] + "..."
                }</span>

                <span class="cov8" title="1">typ := pkg.Type
                if len(typ) &gt; 13 </span><span class="cov0" title="0">{
                        typ = typ[:10] + "..."
                }</span>

                <span class="cov8" title="1">nameCell := lipgloss.NewStyle().Width(20).Render(name)
                versionCell := lipgloss.NewStyle().Width(15).Render(version)
                typeCell := lipgloss.NewStyle().Width(15).Render(typ)

                row := lipgloss.JoinHorizontal(lipgloss.Top, nameCell, versionCell, typeCell)
                rows = append(rows, row)</span>
        }

        <span class="cov8" title="1">return rows</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package ui

import (
        "strings"

        "github.com/charmbracelet/lipgloss"
)

// ProgressBar renders a visual progress indicator.
type ProgressBar struct {
        styles   *Styles
        width    int
        progress float64 // 0.0 to 1.0
        label    string
        showPct  bool
}

// NewProgressBar creates a new progress bar.
func NewProgressBar(styles *Styles, width int) *ProgressBar <span class="cov8" title="1">{
        return &amp;ProgressBar{
                styles:  styles,
                width:   width,
                showPct: true,
        }
}</span>

// SetProgress sets the progress value (0.0 to 1.0).
func (p *ProgressBar) SetProgress(value float64) <span class="cov8" title="1">{
        if value &lt; 0 </span><span class="cov8" title="1">{
                value = 0
        }</span>
        <span class="cov8" title="1">if value &gt; 1 </span><span class="cov8" title="1">{
                value = 1
        }</span>
        <span class="cov8" title="1">p.progress = value</span>
}

// SetLabel sets the progress bar label.
func (p *ProgressBar) SetLabel(label string) <span class="cov8" title="1">{
        p.label = label
}</span>

// SetWidth sets the width of the progress bar.
func (p *ProgressBar) SetWidth(width int) <span class="cov8" title="1">{
        p.width = width
}</span>

// SetShowPercentage toggles percentage display.
func (p *ProgressBar) SetShowPercentage(show bool) <span class="cov8" title="1">{
        p.showPct = show
}</span>

// Progress returns the current progress value.
func (p *ProgressBar) Progress() float64 <span class="cov8" title="1">{
        return p.progress
}</span>

// View renders the progress bar.
func (p *ProgressBar) View() string <span class="cov8" title="1">{
        // Calculate bar width (accounting for brackets and percentage)
        pctText := ""
        if p.showPct </span><span class="cov8" title="1">{
                pctText = " 100%"
        }</span>

        <span class="cov8" title="1">barWidth := p.width - 2 - len(pctText) // 2 for [ ]
        if barWidth &lt; 10 </span><span class="cov0" title="0">{
                barWidth = 10
        }</span>

        // Calculate filled portion
        <span class="cov8" title="1">filled := int(float64(barWidth) * p.progress)
        if filled &gt; barWidth </span><span class="cov0" title="0">{
                filled = barWidth
        }</span>

        // Build the bar
        <span class="cov8" title="1">filledChar := "█"
        emptyChar := "░"

        filledPart := strings.Repeat(filledChar, filled)
        emptyPart := strings.Repeat(emptyChar, barWidth-filled)

        // Get theme for colors
        theme := GetTheme("matrix")
        if p.styles != nil </span>{<span class="cov0" title="0">
                // Use style colors
        }</span>

        <span class="cov8" title="1">filledStyle := lipgloss.NewStyle().Foreground(theme.Primary)
        emptyStyle := lipgloss.NewStyle().Foreground(theme.Muted)

        bar := "[" + filledStyle.Render(filledPart) + emptyStyle.Render(emptyPart) + "]"

        // Add percentage
        if p.showPct </span><span class="cov8" title="1">{
                pct := int(p.progress * 100)
                pctStyle := lipgloss.NewStyle().Foreground(theme.Secondary)
                bar += pctStyle.Render(" " + padLeft(pct, 3) + "%")
        }</span>

        // Add label if present
        <span class="cov8" title="1">if p.label != "" </span><span class="cov8" title="1">{
                labelStyle := lipgloss.NewStyle().Foreground(theme.Secondary)
                return labelStyle.Render(p.label) + "\n" + bar
        }</span>

        <span class="cov8" title="1">return bar</span>
}

// padLeft pads a number with spaces on the left.
func padLeft(n, width int) string <span class="cov8" title="1">{
        s := ""
        for i := 0; i &lt; width; i++ </span><span class="cov8" title="1">{
                s = " " + s
        }</span>
        <span class="cov8" title="1">ns := string(rune('0'+n%10)) + s
        n /= 10
        for i := 1; i &lt; width &amp;&amp; n &gt; 0; i++ </span><span class="cov8" title="1">{
                ns = string(rune('0'+n%10)) + ns[1:]
                n /= 10
        }</span>
        <span class="cov8" title="1">return ns[:width]</span>
}

// Spinner provides animated loading indicators.
type Spinner struct {
        frames  []string
        current int
}

// NewSpinner creates a new spinner with default frames.
func NewSpinner() *Spinner <span class="cov8" title="1">{
        return &amp;Spinner{
                frames: []string{"⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"},
        }
}</span>

// Frame returns the current spinner frame and advances.
func (s *Spinner) Frame() string <span class="cov8" title="1">{
        frame := s.frames[s.current]
        s.current = (s.current + 1) % len(s.frames)
        return frame
}</span>

// Reset resets the spinner to the first frame.
func (s *Spinner) Reset() <span class="cov8" title="1">{
        s.current = 0
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package ui

import (
        "fmt"
        "strings"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"

        "github.com/infktd/devdash/internal/config"
)

// FieldType represents the type of setting field.
type FieldType int

const (
        FieldToggle FieldType = iota // Boolean on/off
        FieldSelect                   // String/int with options
        FieldButton                   // Action buttons (Save/Cancel)
)

// SelectOption represents an option in a Select field.
type SelectOption struct {
        Label string      // Display name
        Value interface{} // Actual value (string or int)
}

// SettingField represents a single setting field.
type SettingField struct {
        Label    string
        Type     FieldType
        Options  []SelectOption // For Select fields
        GetValue func() interface{}
        SetValue func(interface{})
}

// SettingsPanel manages the settings modal.
type SettingsPanel struct {
        // Configuration
        config *config.Config
        styles *Styles

        // Display state
        visible bool
        width   int
        height  int

        // Navigation state
        selectedField int  // Current field index (0-7)
        editMode      bool // True when editing a Select field

        // Working copy of values (not committed until Save)
        workingCopy struct {
                autoDiscover   bool
                scanDepth      int
                defaultLogView string
                theme          string
                systemNotifs   bool
                tuiAlerts      bool
        }

        // Field definitions
        fields []SettingField
}

// settingsSavedMsg is sent when settings are successfully saved.
type settingsSavedMsg struct{}

// settingsSaveErrorMsg is sent when settings fail to save.
type settingsSaveErrorMsg struct {
        err error
}

// NewSettingsPanel creates a settings panel from the current config.
func NewSettingsPanel(cfg *config.Config, styles *Styles, width, height int) *SettingsPanel <span class="cov8" title="1">{
        sp := &amp;SettingsPanel{
                config: cfg,
                styles: styles,
                width:  width,
                height: height,
        }
        sp.loadWorkingCopy()
        sp.buildFields()
        return sp
}</span>

// loadWorkingCopy copies config values to working copy.
func (sp *SettingsPanel) loadWorkingCopy() <span class="cov8" title="1">{
        sp.workingCopy.autoDiscover = sp.config.Projects.AutoDiscover
        sp.workingCopy.scanDepth = sp.config.Projects.ScanDepth
        sp.workingCopy.theme = sp.config.UI.Theme
        sp.workingCopy.defaultLogView = sp.config.UI.DefaultLogView
        sp.workingCopy.systemNotifs = sp.config.Notifications.SystemEnabled
        sp.workingCopy.tuiAlerts = sp.config.Notifications.TUIAlerts
}</span>

// applyWorkingCopy applies working copy to config.
func (sp *SettingsPanel) applyWorkingCopy() <span class="cov8" title="1">{
        sp.config.Projects.AutoDiscover = sp.workingCopy.autoDiscover
        sp.config.Projects.ScanDepth = sp.workingCopy.scanDepth
        sp.config.UI.Theme = sp.workingCopy.theme
        sp.config.UI.DefaultLogView = sp.workingCopy.defaultLogView
        sp.config.Notifications.SystemEnabled = sp.workingCopy.systemNotifs
        sp.config.Notifications.TUIAlerts = sp.workingCopy.tuiAlerts
}</span>

// buildFields creates the field definitions.
func (sp *SettingsPanel) buildFields() <span class="cov8" title="1">{
        sp.fields = []SettingField{
                {
                        Label: "Auto-discover projects",
                        Type:  FieldToggle,
                        GetValue: func() interface{} </span><span class="cov8" title="1">{
                                return sp.workingCopy.autoDiscover
                        }</span>,
                        SetValue: func(v interface{}) <span class="cov8" title="1">{
                                sp.workingCopy.autoDiscover = v.(bool)
                        }</span>,
                },
                {
                        Label: "Scan depth",
                        Type:  FieldSelect,
                        Options: []SelectOption{
                                {Label: "1", Value: 1},
                                {Label: "2", Value: 2},
                                {Label: "3", Value: 3},
                                {Label: "4", Value: 4},
                                {Label: "5", Value: 5},
                        },
                        GetValue: func() interface{} <span class="cov8" title="1">{
                                return sp.workingCopy.scanDepth
                        }</span>,
                        SetValue: func(v interface{}) <span class="cov8" title="1">{
                                sp.workingCopy.scanDepth = v.(int)
                        }</span>,
                },
                {
                        Label: "Default log view",
                        Type:  FieldSelect,
                        Options: []SelectOption{
                                {Label: "Focused", Value: "focused"},
                                {Label: "Unified", Value: "unified"},
                        },
                        GetValue: func() interface{} <span class="cov8" title="1">{
                                return sp.workingCopy.defaultLogView
                        }</span>,
                        SetValue: func(v interface{}) <span class="cov0" title="0">{
                                sp.workingCopy.defaultLogView = v.(string)
                        }</span>,
                },
                {
                        Label: "Theme",
                        Type:  FieldSelect,
                        Options: []SelectOption{
                                {Label: "Acid Green", Value: "matrix"},
                                {Label: "Gruvbox", Value: "gruvbox"},
                                {Label: "Dracula", Value: "dracula"},
                                {Label: "Nord", Value: "nord"},
                                {Label: "Tokyo Night", Value: "tokyo-night"},
                                {Label: "Ayu Dark", Value: "ayu-dark"},
                                {Label: "Solarized Dark", Value: "solarized-dark"},
                                {Label: "Monokai", Value: "monokai"},
                        },
                        GetValue: func() interface{} <span class="cov8" title="1">{
                                return sp.workingCopy.theme
                        }</span>,
                        SetValue: func(v interface{}) <span class="cov8" title="1">{
                                sp.workingCopy.theme = v.(string)
                        }</span>,
                },
                {
                        Label: "System notifications",
                        Type:  FieldToggle,
                        GetValue: func() interface{} <span class="cov8" title="1">{
                                return sp.workingCopy.systemNotifs
                        }</span>,
                        SetValue: func(v interface{}) <span class="cov0" title="0">{
                                sp.workingCopy.systemNotifs = v.(bool)
                        }</span>,
                },
                {
                        Label: "TUI alerts",
                        Type:  FieldToggle,
                        GetValue: func() interface{} <span class="cov8" title="1">{
                                return sp.workingCopy.tuiAlerts
                        }</span>,
                        SetValue: func(v interface{}) <span class="cov0" title="0">{
                                sp.workingCopy.tuiAlerts = v.(bool)
                        }</span>,
                },
                {
                        Label: "Save",
                        Type:  FieldButton,
                },
                {
                        Label: "Cancel",
                        Type:  FieldButton,
                },
        }
}

// Show makes the settings panel visible.
func (sp *SettingsPanel) Show() tea.Cmd <span class="cov8" title="1">{
        sp.visible = true
        sp.selectedField = 0
        sp.editMode = false
        sp.loadWorkingCopy()
        return nil
}</span>

// Hide closes the settings panel.
func (sp *SettingsPanel) Hide() <span class="cov8" title="1">{
        sp.visible = false
}</span>

// IsVisible returns whether the panel is shown.
func (sp *SettingsPanel) IsVisible() bool <span class="cov8" title="1">{
        return sp.visible
}</span>

// SetSize updates the panel dimensions.
func (sp *SettingsPanel) SetSize(width, height int) <span class="cov8" title="1">{
        sp.width = width
        sp.height = height
}</span>

// Cancel discards changes and closes the panel.
func (sp *SettingsPanel) Cancel() <span class="cov8" title="1">{
        sp.loadWorkingCopy()
        sp.visible = false
}</span>

// Update handles messages for the settings panel.
func (sp *SettingsPanel) Update(msg tea.Msg) (*SettingsPanel, tea.Cmd) <span class="cov8" title="1">{
        if !sp.visible </span><span class="cov8" title="1">{
                return sp, nil
        }</span>

        <span class="cov8" title="1">keyMsg, ok := msg.(tea.KeyMsg)
        if !ok </span><span class="cov8" title="1">{
                return sp, nil
        }</span>

        // Handle edit mode first (for Select fields)
        <span class="cov8" title="1">if sp.editMode </span><span class="cov8" title="1">{
                return sp.handleEditMode(keyMsg)
        }</span>

        // Normal navigation mode
        <span class="cov8" title="1">return sp.handleNavigationMode(keyMsg)</span>
}

// handleNavigationMode handles keys in navigation mode.
func (sp *SettingsPanel) handleNavigationMode(msg tea.KeyMsg) (*SettingsPanel, tea.Cmd) <span class="cov8" title="1">{
        switch msg.String() </span>{
        case "up", "k":<span class="cov8" title="1">
                if sp.selectedField &gt; 0 </span><span class="cov8" title="1">{
                        sp.selectedField--
                }</span>

        case "down", "j":<span class="cov8" title="1">
                if sp.selectedField &lt; len(sp.fields)-1 </span><span class="cov8" title="1">{
                        sp.selectedField++
                }</span>

        case "enter":<span class="cov8" title="1">
                return sp.handleFieldActivation()</span>

        case "esc":<span class="cov8" title="1">
                sp.Cancel()
                return sp, nil</span>
        }

        <span class="cov8" title="1">return sp, nil</span>
}

// handleEditMode handles keys in edit mode (for Select fields).
func (sp *SettingsPanel) handleEditMode(msg tea.KeyMsg) (*SettingsPanel, tea.Cmd) <span class="cov8" title="1">{
        field := sp.fields[sp.selectedField]

        switch msg.String() </span>{
        case "left", "h":<span class="cov8" title="1">
                sp.cyclePrevOption(field)</span>

        case "right", "l":<span class="cov8" title="1">
                sp.cycleNextOption(field)</span>

        case "enter":<span class="cov8" title="1">
                // Confirm selection and exit edit mode
                sp.editMode = false</span>

        case "esc":<span class="cov8" title="1">
                // Cancel edit mode (value remains unchanged)
                sp.editMode = false</span>
        }

        <span class="cov8" title="1">return sp, nil</span>
}

// handleFieldActivation activates the current field.
func (sp *SettingsPanel) handleFieldActivation() (*SettingsPanel, tea.Cmd) <span class="cov8" title="1">{
        field := sp.fields[sp.selectedField]

        switch field.Type </span>{
        case FieldToggle:<span class="cov8" title="1">
                // Flip boolean immediately
                currentValue := field.GetValue().(bool)
                field.SetValue(!currentValue)</span>

        case FieldSelect:<span class="cov8" title="1">
                // Enter edit mode to use Left/Right arrows
                sp.editMode = true</span>

        case FieldButton:<span class="cov8" title="1">
                if field.Label == "Save" </span><span class="cov8" title="1">{
                        return sp.handleSave()
                }</span> else<span class="cov8" title="1"> if field.Label == "Cancel" </span><span class="cov8" title="1">{
                        sp.Cancel()
                }</span>
        }

        <span class="cov8" title="1">return sp, nil</span>
}

// handleSave saves settings to disk.
func (sp *SettingsPanel) handleSave() (*SettingsPanel, tea.Cmd) <span class="cov8" title="1">{
        // Apply working copy to config
        sp.applyWorkingCopy()

        // Save to disk
        path := config.Path()
        err := config.Save(path, sp.config)

        if err != nil </span><span class="cov0" title="0">{
                // Return error as a message for toast notification
                return sp, func() tea.Msg </span><span class="cov0" title="0">{
                        return settingsSaveErrorMsg{err: err}
                }</span>
        }

        // Success - close modal
        <span class="cov8" title="1">sp.visible = false
        return sp, func() tea.Msg </span><span class="cov8" title="1">{
                return settingsSavedMsg{}
        }</span>
}

// cyclePrevOption cycles to previous option in a Select field.
func (sp *SettingsPanel) cyclePrevOption(field SettingField) <span class="cov8" title="1">{
        currentValue := field.GetValue()
        currentIdx := -1

        for i, opt := range field.Options </span><span class="cov8" title="1">{
                if opt.Value == currentValue </span><span class="cov8" title="1">{
                        currentIdx = i
                        break</span>
                }
        }

        <span class="cov8" title="1">if currentIdx &gt; 0 </span><span class="cov8" title="1">{
                field.SetValue(field.Options[currentIdx-1].Value)
        }</span> else<span class="cov8" title="1"> {
                // Wrap around to last option
                field.SetValue(field.Options[len(field.Options)-1].Value)
        }</span>
}

// cycleNextOption cycles to next option in a Select field.
func (sp *SettingsPanel) cycleNextOption(field SettingField) <span class="cov8" title="1">{
        currentValue := field.GetValue()
        currentIdx := -1

        for i, opt := range field.Options </span><span class="cov8" title="1">{
                if opt.Value == currentValue </span><span class="cov8" title="1">{
                        currentIdx = i
                        break</span>
                }
        }

        <span class="cov8" title="1">if currentIdx &lt; len(field.Options)-1 </span><span class="cov8" title="1">{
                field.SetValue(field.Options[currentIdx+1].Value)
        }</span> else<span class="cov8" title="1"> {
                // Wrap around to first option
                field.SetValue(field.Options[0].Value)
        }</span>
}

// View renders the settings panel.
func (sp *SettingsPanel) View() string <span class="cov8" title="1">{
        if !sp.visible </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Build modal content
        <span class="cov8" title="1">content := sp.renderContent()

        // Fixed size modal box (60 cols x 20 rows)
        modalStyle := sp.styles.ModalBorder.
                Width(60).
                Height(20).
                Padding(1, 2)

        return modalStyle.Render(content)</span>
}

// renderContent builds the modal content.
func (sp *SettingsPanel) renderContent() string <span class="cov8" title="1">{
        var lines []string

        // Title (centered)
        titleStyle := lipgloss.NewStyle().Width(56).Align(lipgloss.Center)
        lines = append(lines, titleStyle.Render(sp.styles.Title.Render("Settings")))
        lines = append(lines, "")

        // Field list (centered)
        fieldStyle := lipgloss.NewStyle().Width(56).Align(lipgloss.Center)
        for i, field := range sp.fields </span><span class="cov8" title="1">{
                line := sp.renderField(i, field)
                lines = append(lines, fieldStyle.Render(line))
        }</span>

        // Help text at bottom (centered)
        <span class="cov8" title="1">lines = append(lines, "")
        helpStyle := lipgloss.NewStyle().Width(56).Align(lipgloss.Center)
        lines = append(lines, helpStyle.Render(sp.styles.Breadcrumb.Render(sp.getHelpText())))

        return lipgloss.JoinVertical(lipgloss.Left, lines...)</span>
}

// renderField renders a single field.
func (sp *SettingsPanel) renderField(idx int, field SettingField) string <span class="cov8" title="1">{
        cursor := "  "
        if idx == sp.selectedField </span><span class="cov8" title="1">{
                cursor = "&gt; "
        }</span>

        <span class="cov8" title="1">var valueDisplay string
        switch field.Type </span>{
        case FieldToggle:<span class="cov8" title="1">
                value := field.GetValue().(bool)
                if value </span><span class="cov8" title="1">{
                        valueDisplay = sp.styles.StatusRunning.Render("[ON]")
                }</span> else<span class="cov0" title="0"> {
                        valueDisplay = sp.styles.StatusIdle.Render("[OFF]")
                }</span>

        case FieldSelect:<span class="cov8" title="1">
                value := field.GetValue()
                // Find matching option label
                for _, opt := range field.Options </span><span class="cov8" title="1">{
                        if opt.Value == value </span><span class="cov8" title="1">{
                                if sp.editMode &amp;&amp; idx == sp.selectedField </span><span class="cov0" title="0">{
                                        // Show all options with current highlighted
                                        valueDisplay = sp.renderSelectOptions(field, value)
                                }</span> else<span class="cov8" title="1"> {
                                        valueDisplay = sp.styles.Breadcrumb.Render(fmt.Sprintf("&lt;%s&gt;", opt.Label))
                                }</span>
                                <span class="cov8" title="1">break</span>
                        }
                }

        case FieldButton:<span class="cov8" title="1">
                // For buttons, center the label
                buttonLabel := fmt.Sprintf("[%s]", field.Label)
                if idx == sp.selectedField </span><span class="cov0" title="0">{
                        buttonLabel = sp.styles.SelectedItem.Render(buttonLabel)
                }</span>
                <span class="cov8" title="1">return buttonLabel</span>
        }

        // Calculate spacing for alignment
        // Total width: 52 chars (56 - 4 for cursor/padding)
        // Label gets left side, value gets right side

        // Calculate padding based on plain text lengths
        <span class="cov8" title="1">valueWidth := lipgloss.Width(valueDisplay)
        padding := 52 - len(cursor) - len(field.Label) - valueWidth
        if padding &lt; 1 </span><span class="cov0" title="0">{
                padding = 1
        }</span>

        // Apply styling if selected
        <span class="cov8" title="1">label := field.Label
        if idx == sp.selectedField &amp;&amp; field.Type != FieldButton </span><span class="cov8" title="1">{
                label = sp.styles.SelectedItem.Render(label)
        }</span>

        // Build the line: cursor + label + padding + value
        <span class="cov8" title="1">line := fmt.Sprintf("%s%s%s%s", cursor, label, strings.Repeat(" ", padding), valueDisplay)

        return line</span>
}

// renderSelectOptions renders inline options for Select field in edit mode.
func (sp *SettingsPanel) renderSelectOptions(field SettingField, currentValue interface{}) string <span class="cov0" title="0">{
        // Display inline options: "1 [2] 3 4 5" with current in brackets
        var parts []string
        for _, opt := range field.Options </span><span class="cov0" title="0">{
                if opt.Value == currentValue </span><span class="cov0" title="0">{
                        parts = append(parts, sp.styles.SelectedItem.Render(fmt.Sprintf("[%s]", opt.Label)))
                }</span> else<span class="cov0" title="0"> {
                        parts = append(parts, opt.Label)
                }</span>
        }
        <span class="cov0" title="0">return strings.Join(parts, " ")</span>
}

// getHelpText returns context-sensitive help text.
func (sp *SettingsPanel) getHelpText() string <span class="cov8" title="1">{
        if sp.editMode </span><span class="cov0" title="0">{
                return "←/→ Change  [Enter] Confirm  [Esc] Cancel"
        }</span>
        <span class="cov8" title="1">return "↑/↓ Navigate  [Enter] Select  [Esc] Cancel"</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package ui

import (
        "fmt"
        "strings"

        "github.com/charmbracelet/lipgloss"
        "github.com/lucasb-eyer/go-colorful"
)

// ASCII art options for devdash
var asciiArtOptions = map[string]string{
        "default": `
 ██████╗ ███████╗██╗   ██╗██████╗  █████╗ ███████╗██╗  ██╗
 ██╔══██╗██╔════╝██║   ██║██╔══██╗██╔══██╗██╔════╝██║  ██║
 ██║  ██║█████╗  ██║   ██║██║  ██║███████║███████╗███████║
 ██║  ██║██╔══╝  ╚██╗ ██╔╝██║  ██║██╔══██║╚════██║██╔══██║
 ██████╔╝███████╗ ╚████╔╝ ██████╔╝██║  ██║███████║██║  ██║
 ╚═════╝ ╚══════╝  ╚═══╝  ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝`,
        "slant": `
    ____  _______    ____  ___   _____ __  __
   / __ \/ ____/ |  / / / / /   / ___// / / /
  / / / / __/  | | / / / / /    \__ \/ /_/ /
 / /_/ / /___  | |/ / /_/ /    ___/ / __  /
/_____/_____/  |___/\____/    /____/_/ /_/
`,
        "small": `
     _                _           _
  __| | _____   ____| | __ _ ___| |__
 / _' |/ _ \ \ / / _' |/ _' / __| '_ \
| (_| |  __/\ V / (_| | (_| \__ \ | | |
 \__,_|\___| \_/ \__,_|\__,_|___/_| |_|
`,
        "minimal": `
┌─────────────────────────────┐
│       d e v D A S H         │
│     devenv control plane    │
└─────────────────────────────┘
`,
        "cyber": `
   ██████  ███████ ██    ██ ██████   █████  ███████ ██   ██
   ██   ██ ██      ██    ██ ██   ██ ██   ██ ██      ██   ██
   ██   ██ █████   ██    ██ ██   ██ ███████ ███████ ███████
   ██   ██ ██       ██  ██  ██   ██ ██   ██      ██ ██   ██
   ██████  ███████   ████   ██████  ██   ██ ███████ ██   ██
`,
}

var defaultAsciiArt = asciiArtOptions["default"]

// SplashScreen displays the startup splash with progress.
type SplashScreen struct {
        styles   *Styles
        width    int
        height   int
        visible  bool
        progress float64 // 0.0 to 1.0
        message  string
        asciiArt string
        frame    int // Animation frame counter
}

// NewSplashScreen creates a new splash screen.
func NewSplashScreen(styles *Styles, width, height int) *SplashScreen <span class="cov8" title="1">{
        return &amp;SplashScreen{
                styles:   styles,
                width:    width,
                height:   height,
                visible:  true,
                progress: 0,
                message:  "Initializing...",
                asciiArt: defaultAsciiArt,
        }
}</span>

// SetProgress updates the progress (0.0 to 1.0).
func (s *SplashScreen) SetProgress(p float64) <span class="cov8" title="1">{
        if p &lt; 0 </span><span class="cov8" title="1">{
                p = 0
        }</span>
        <span class="cov8" title="1">if p &gt; 1 </span><span class="cov8" title="1">{
                p = 1
        }</span>
        <span class="cov8" title="1">s.progress = p</span>
}

// SetMessage updates the status message.
func (s *SplashScreen) SetMessage(msg string) <span class="cov8" title="1">{
        s.message = msg
}</span>

// SetAsciiArt allows customizing the ASCII art.
func (s *SplashScreen) SetAsciiArt(art string) <span class="cov8" title="1">{
        s.asciiArt = art
}</span>

// SetAsciiArtByName sets the ASCII art by preset name.
// Available options: "default", "block", "small", "minimal", "hacker"
func (s *SplashScreen) SetAsciiArtByName(name string) <span class="cov8" title="1">{
        if art, ok := asciiArtOptions[name]; ok </span><span class="cov8" title="1">{
                s.asciiArt = art
        }</span>
}

// GetAsciiArtNames returns available ASCII art preset names.
func GetAsciiArtNames() []string <span class="cov8" title="1">{
        return []string{"default", "block", "small", "minimal", "hacker"}
}</span>

// Show makes the splash screen visible.
func (s *SplashScreen) Show() <span class="cov8" title="1">{
        s.visible = true
}</span>

// Hide dismisses the splash screen.
func (s *SplashScreen) Hide() <span class="cov8" title="1">{
        s.visible = false
}</span>

// IsVisible returns whether the splash is shown.
func (s *SplashScreen) IsVisible() bool <span class="cov8" title="1">{
        return s.visible
}</span>

// SetSize updates dimensions.
func (s *SplashScreen) SetSize(width, height int) <span class="cov8" title="1">{
        s.width = width
        s.height = height
}</span>

// View renders the splash screen.
func (s *SplashScreen) View() string <span class="cov8" title="1">{
        if !s.visible </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Get theme colors
        <span class="cov8" title="1">primaryColor := lipgloss.Color("#00FF00") // Default
        mutedColor := lipgloss.Color("#555555")
        if s.styles != nil </span><span class="cov8" title="1">{
                primaryColor = s.styles.theme.Primary
                mutedColor = s.styles.theme.Muted
        }</span>

        // Style the ASCII art with bold primary color
        <span class="cov8" title="1">artStyle := lipgloss.NewStyle().
                Foreground(primaryColor).
                Bold(true)
        art := artStyle.Render(s.asciiArt)

        // Tagline
        taglineStyle := lipgloss.NewStyle().
                Foreground(mutedColor).
                Italic(true)
        tagline := taglineStyle.Render("── devenv fleet control ──")

        // Message
        msgStyle := lipgloss.NewStyle().
                Foreground(lipgloss.Color("#888888"))
        message := msgStyle.Render(s.message)

        // Progress bar
        progressBar := s.renderProgressBar()

        // Combine all elements
        content := lipgloss.JoinVertical(
                lipgloss.Center,
                art,
                "",
                tagline,
                "",
                message,
                progressBar,
        )

        // Center in the screen
        containerStyle := lipgloss.NewStyle().
                Width(s.width).
                Height(s.height).
                Align(lipgloss.Center, lipgloss.Center)

        return containerStyle.Render(content)</span>
}

func (s *SplashScreen) renderProgressBar() string <span class="cov8" title="1">{
        barWidth := 40
        filled := int(s.progress * float64(barWidth))

        // Get theme colors for gradient
        primaryHex := "#00FF00"
        secondaryHex := "#00FFFF" // Cyan as secondary gradient color
        mutedHex := "#333333"
        if s.styles != nil </span><span class="cov8" title="1">{
                primaryHex = string(s.styles.theme.Primary)
                mutedHex = string(s.styles.theme.Muted)
                // Use secondary color for the gradient end
                secondaryHex = string(s.styles.theme.Secondary)
        }</span>

        // Parse colors for gradient blending
        <span class="cov8" title="1">primaryCol, _ := colorful.Hex(primaryHex)
        secondaryCol, _ := colorful.Hex(secondaryHex)

        // Wave characters for leading edge animation
        waveChars := []rune{'▓', '▒', '░'}

        // Build the progress bar with per-character gradient coloring
        var result strings.Builder
        result.WriteString("[")

        for i := 0; i &lt; barWidth; i++ </span><span class="cov8" title="1">{
                if i &lt; filled </span><span class="cov8" title="1">{
                        // Calculate gradient position (0.0 to 1.0 across filled portion)
                        var gradientPos float64
                        if filled &gt; 1 </span><span class="cov8" title="1">{
                                gradientPos = float64(i) / float64(filled-1)
                        }</span>

                        // Blend colors for gradient effect
                        <span class="cov8" title="1">blendedColor := primaryCol.BlendLuv(secondaryCol, gradientPos)

                        // Determine character (wave animation at leading edge)
                        char := '█'
                        if i &gt;= filled-3 &amp;&amp; filled &lt; barWidth </span><span class="cov8" title="1">{
                                waveIdx := (filled - 1 - i + s.frame) % 3
                                if waveIdx &lt; 0 </span><span class="cov0" title="0">{
                                        waveIdx = 0
                                }</span>
                                <span class="cov8" title="1">char = waveChars[waveIdx]</span>
                        }

                        // Apply gradient color to this character
                        <span class="cov8" title="1">charStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(blendedColor.Hex()))
                        result.WriteString(charStyle.Render(string(char)))</span>
                } else<span class="cov8" title="1"> {
                        // Empty portion
                        emptyStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(mutedHex))
                        result.WriteString(emptyStyle.Render("░"))
                }</span>
        }

        <span class="cov8" title="1">result.WriteString("] ")

        // Percentage
        percent := fmt.Sprintf("%3.0f%%", s.progress*100)
        percentStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("#888888")).Bold(true)
        result.WriteString(percentStyle.Render(percent))

        return result.String()</span>
}

// Tick advances the animation frame.
func (s *SplashScreen) Tick() <span class="cov8" title="1">{
        s.frame++
}</span>

// Progress returns the current progress value.
func (s *SplashScreen) Progress() float64 <span class="cov8" title="1">{
        return s.progress
}</span>

// Message returns the current message.
func (s *SplashScreen) Message() string <span class="cov8" title="1">{
        return s.message
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package ui

import "github.com/charmbracelet/lipgloss"

// Styles holds all the styled components.
type Styles struct {
        // Theme reference
        theme Theme

        // Layout
        Header  lipgloss.Style
        Footer  lipgloss.Style
        Sidebar lipgloss.Style
        Main    lipgloss.Style

        // Components
        Title         lipgloss.Style
        Breadcrumb    lipgloss.Style
        StatusBar     lipgloss.Style
        ProjectItem   lipgloss.Style
        SelectedItem  lipgloss.Style
        ServiceRow    lipgloss.Style
        LogLine       lipgloss.Style
        LogTimestamp  lipgloss.Style
        LogLevelInfo  lipgloss.Style
        LogLevelWarn  lipgloss.Style
        LogLevelError lipgloss.Style

        // Status indicators
        StatusRunning  lipgloss.Style
        StatusIdle     lipgloss.Style
        StatusDegraded lipgloss.Style
        StatusStale    lipgloss.Style
        StatusMissing  lipgloss.Style

        // Borders
        FocusedBorder lipgloss.Style
        BlurredBorder lipgloss.Style
        ModalBorder   lipgloss.Style
}

// NewStyles creates styles from a theme.
func NewStyles(theme Theme) *Styles <span class="cov8" title="1">{
        return &amp;Styles{
                // Theme reference
                theme: theme,

                // Layout
                Header: lipgloss.NewStyle().
                        Foreground(theme.Primary).
                        Bold(true).
                        Padding(0, 1),

                Footer: lipgloss.NewStyle().
                        Foreground(theme.Muted).
                        Padding(0, 1),

                Sidebar: lipgloss.NewStyle().
                        BorderStyle(lipgloss.RoundedBorder()).
                        BorderForeground(theme.Muted).
                        Padding(0, 1),

                Main: lipgloss.NewStyle().
                        BorderStyle(lipgloss.RoundedBorder()).
                        BorderForeground(theme.Muted).
                        Padding(0, 1),

                // Components
                Title: lipgloss.NewStyle().
                        Foreground(theme.Primary).
                        Bold(true),

                Breadcrumb: lipgloss.NewStyle().
                        Foreground(theme.Muted),

                StatusBar: lipgloss.NewStyle().
                        Foreground(theme.Secondary),

                ProjectItem: lipgloss.NewStyle().
                        Foreground(theme.Secondary),

                SelectedItem: lipgloss.NewStyle().
                        Foreground(theme.Primary).
                        Bold(true),

                ServiceRow: lipgloss.NewStyle().
                        Foreground(theme.Secondary),

                LogLine: lipgloss.NewStyle().
                        Foreground(theme.Secondary),

                LogTimestamp: lipgloss.NewStyle().
                        Foreground(theme.Muted),

                LogLevelInfo: lipgloss.NewStyle().
                        Foreground(theme.Muted),

                LogLevelWarn: lipgloss.NewStyle().
                        Foreground(theme.Warning),

                LogLevelError: lipgloss.NewStyle().
                        Foreground(theme.Error).
                        Bold(true),

                // Status indicators
                StatusRunning: lipgloss.NewStyle().
                        Foreground(theme.Success),

                StatusIdle: lipgloss.NewStyle().
                        Foreground(theme.Muted),

                StatusDegraded: lipgloss.NewStyle().
                        Foreground(theme.Warning),

                StatusStale: lipgloss.NewStyle().
                        Foreground(theme.Error),

                StatusMissing: lipgloss.NewStyle().
                        Foreground(theme.Error),

                // Borders - FocusedBorder uses rounded with primary color for emphasis
                FocusedBorder: lipgloss.NewStyle().
                        BorderStyle(lipgloss.RoundedBorder()).
                        BorderForeground(theme.Primary),

                BlurredBorder: lipgloss.NewStyle().
                        BorderStyle(lipgloss.RoundedBorder()).
                        BorderForeground(theme.Muted),

                // Modal border - keeps rounded for softer look on dialogs
                ModalBorder: lipgloss.NewStyle().
                        BorderStyle(lipgloss.RoundedBorder()).
                        BorderForeground(theme.Primary),
        }
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package ui

import "github.com/charmbracelet/lipgloss"

// Theme defines the color palette for the UI.
type Theme struct {
        Name       string
        Primary    lipgloss.Color
        Secondary  lipgloss.Color
        Background lipgloss.Color
        Muted      lipgloss.Color
        Success    lipgloss.Color
        Warning    lipgloss.Color
        Error      lipgloss.Color
}

// Themes contains all available themes.
var Themes = map[string]Theme{
        // Matrix - Classic green on black hacker theme
        "matrix": {
                Name:       "matrix",
                Primary:    lipgloss.Color("#39FF14"),
                Secondary:  lipgloss.Color("#00FF41"),
                Background: lipgloss.Color("#0D0D0D"),
                Muted:      lipgloss.Color("#4A4A4A"),
                Success:    lipgloss.Color("#00FF41"),
                Warning:    lipgloss.Color("#FFD700"),
                Error:      lipgloss.Color("#FF4136"),
        },

        // Gruvbox - Retro groove colors
        "gruvbox": {
                Name:       "gruvbox",
                Primary:    lipgloss.Color("#FE8019"), // Orange
                Secondary:  lipgloss.Color("#FABD2F"), // Yellow
                Background: lipgloss.Color("#282828"),
                Muted:      lipgloss.Color("#928374"),
                Success:    lipgloss.Color("#B8BB26"), // Green
                Warning:    lipgloss.Color("#FABD2F"), // Yellow
                Error:      lipgloss.Color("#FB4934"), // Red
        },

        // Dracula - Dark purple theme
        "dracula": {
                Name:       "dracula",
                Primary:    lipgloss.Color("#BD93F9"), // Purple
                Secondary:  lipgloss.Color("#FF79C6"), // Pink
                Background: lipgloss.Color("#282A36"),
                Muted:      lipgloss.Color("#6272A4"),
                Success:    lipgloss.Color("#50FA7B"), // Green
                Warning:    lipgloss.Color("#F1FA8C"), // Yellow
                Error:      lipgloss.Color("#FF5555"), // Red
        },

        // Nord - Cool arctic theme
        "nord": {
                Name:       "nord",
                Primary:    lipgloss.Color("#88C0D0"), // Frost blue
                Secondary:  lipgloss.Color("#81A1C1"), // Light blue
                Background: lipgloss.Color("#2E3440"),
                Muted:      lipgloss.Color("#4C566A"),
                Success:    lipgloss.Color("#A3BE8C"), // Green
                Warning:    lipgloss.Color("#EBCB8B"), // Yellow
                Error:      lipgloss.Color("#BF616A"), // Red
        },

        // Tokyo Night - Clean modern theme
        "tokyo-night": {
                Name:       "tokyo-night",
                Primary:    lipgloss.Color("#7AA2F7"), // Blue
                Secondary:  lipgloss.Color("#BB9AF7"), // Purple
                Background: lipgloss.Color("#1A1B26"),
                Muted:      lipgloss.Color("#565F89"),
                Success:    lipgloss.Color("#9ECE6A"), // Green
                Warning:    lipgloss.Color("#E0AF68"), // Yellow
                Error:      lipgloss.Color("#F7768E"), // Red
        },

        // Ayu Dark - Golden/orange accents
        "ayu-dark": {
                Name:       "ayu-dark",
                Primary:    lipgloss.Color("#FFB454"), // Orange/golden
                Secondary:  lipgloss.Color("#F07178"), // Coral
                Background: lipgloss.Color("#0A0E14"),
                Muted:      lipgloss.Color("#4D5566"),
                Success:    lipgloss.Color("#C2D94C"), // Lime green
                Warning:    lipgloss.Color("#FFB454"), // Orange
                Error:      lipgloss.Color("#F07178"), // Red/coral
        },

        // Solarized Dark - Scientific muted palette
        "solarized-dark": {
                Name:       "solarized-dark",
                Primary:    lipgloss.Color("#268BD2"), // Blue
                Secondary:  lipgloss.Color("#2AA198"), // Cyan
                Background: lipgloss.Color("#002B36"),
                Muted:      lipgloss.Color("#586E75"),
                Success:    lipgloss.Color("#859900"), // Green
                Warning:    lipgloss.Color("#B58900"), // Yellow
                Error:      lipgloss.Color("#DC322F"), // Red
        },

        // Monokai - Classic editor theme
        "monokai": {
                Name:       "monokai",
                Primary:    lipgloss.Color("#F92672"), // Pink/magenta
                Secondary:  lipgloss.Color("#FD971F"), // Orange
                Background: lipgloss.Color("#272822"),
                Muted:      lipgloss.Color("#75715E"),
                Success:    lipgloss.Color("#A6E22E"), // Green
                Warning:    lipgloss.Color("#E6DB74"), // Yellow
                Error:      lipgloss.Color("#F92672"), // Pink/red
        },
}

// GetTheme returns a theme by name, defaulting to matrix.
func GetTheme(name string) Theme <span class="cov8" title="1">{
        if theme, ok := Themes[name]; ok </span><span class="cov8" title="1">{
                return theme
        }</span>
        <span class="cov8" title="1">return Themes["matrix"]</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package ui

import (
        "time"

        tea "github.com/charmbracelet/bubbletea"
        "github.com/charmbracelet/lipgloss"
        "github.com/lucasb-eyer/go-colorful"
)

// ToastLevel represents the severity of a toast notification.
type ToastLevel int

const (
        ToastInfo ToastLevel = iota
        ToastSuccess
        ToastWarn
        ToastError
)

// Toast represents a notification banner.
type Toast struct {
        Message   string
        Level     ToastLevel
        CreatedAt time.Time
        Duration  time.Duration // Auto-dismiss after this duration, 0 = no auto-dismiss
}

// ToastManager manages toast notification display.
type ToastManager struct {
        current   *Toast
        styles    *Styles
        width     int
        visible   bool
        dismissed bool
        opacity   float64 // 0.0 to 1.0 for fade-in animation
}

// NewToastManager creates a toast manager.
func NewToastManager(styles *Styles, width int) *ToastManager <span class="cov8" title="1">{
        return &amp;ToastManager{
                styles: styles,
                width:  width,
        }
}</span>

// Show displays a toast notification.
func (tm *ToastManager) Show(msg string, level ToastLevel, duration time.Duration) <span class="cov8" title="1">{
        tm.current = &amp;Toast{
                Message:   msg,
                Level:     level,
                CreatedAt: time.Now(),
                Duration:  duration,
        }
        tm.visible = true
        tm.dismissed = false
        tm.opacity = 0.0 // Start invisible for fade-in
}</span>

// Dismiss hides the current toast.
func (tm *ToastManager) Dismiss() <span class="cov8" title="1">{
        tm.visible = false
        tm.dismissed = true
}</span>

// IsVisible returns whether a toast is currently shown.
func (tm *ToastManager) IsVisible() bool <span class="cov8" title="1">{
        return tm.visible &amp;&amp; tm.current != nil
}</span>

// Current returns the current toast (may be nil).
func (tm *ToastManager) Current() *Toast <span class="cov8" title="1">{
        return tm.current
}</span>

// View renders the toast notification.
func (tm *ToastManager) View() string <span class="cov8" title="1">{
        if !tm.IsVisible() </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">toast := tm.current

        // Get icon and color based on level
        var icon string
        var color lipgloss.Color

        if tm.styles != nil </span><span class="cov8" title="1">{
                switch toast.Level </span>{
                case ToastInfo:<span class="cov8" title="1">
                        icon = "ℹ"
                        color = lipgloss.Color("#88C0D0")</span> // Blue
                case ToastSuccess:<span class="cov8" title="1">
                        icon = "✓"
                        color = lipgloss.Color("#00FF41")</span> // Green
                case ToastWarn:<span class="cov8" title="1">
                        icon = "⚠"
                        color = lipgloss.Color("#FFD700")</span> // Yellow
                case ToastError:<span class="cov8" title="1">
                        icon = "✗"
                        color = lipgloss.Color("#FF4136")</span> // Red
                default:<span class="cov0" title="0">
                        icon = "ℹ"
                        color = tm.styles.theme.Primary</span>
                }
        }

        // Dynamic width based on terminal, leaving room for other UI elements
        // Use 70% of terminal width, with min 60 and max 120
        <span class="cov8" title="1">maxWidth := tm.width * 70 / 100
        if maxWidth &lt; 60 </span><span class="cov8" title="1">{
                maxWidth = 60
        }</span>
        <span class="cov8" title="1">if maxWidth &gt; 120 </span><span class="cov8" title="1">{
                maxWidth = 120
        }</span>
        <span class="cov8" title="1">messageSpace := maxWidth - len(icon) - 2 // icon + space

        message := toast.Message
        if len(message) &gt; messageSpace </span><span class="cov8" title="1">{
                message = message[:messageSpace-3] + "..."
        }</span>

        <span class="cov8" title="1">content := icon + " " + message

        // Apply fade-in effect by blending color with background
        finalColor := color
        if tm.opacity &lt; 1.0 </span><span class="cov8" title="1">{
                // Blend from dark gray to target color
                bgColor, _ := colorful.Hex("#1a1a1a")
                targetColor, _ := colorful.Hex(string(color))
                blended := bgColor.BlendLuv(targetColor, tm.opacity)
                finalColor = lipgloss.Color(blended.Hex())
        }</span>

        // Simple inline style with color
        <span class="cov8" title="1">style := lipgloss.NewStyle().
                Foreground(finalColor).
                Bold(true)

        return style.Render(content)</span>
}

// ToastTickMsg is a tick message for auto-dismiss.
type ToastTickMsg time.Time

// TickCmd returns a command that ticks every 100ms for toast management.
func (tm *ToastManager) TickCmd() tea.Cmd <span class="cov8" title="1">{
        return tea.Tick(100*time.Millisecond, func(t time.Time) tea.Msg </span><span class="cov0" title="0">{
                return ToastTickMsg(t)
        }</span>)
}

// Update handles toast tick messages.
func (tm *ToastManager) Update(msg tea.Msg) (*ToastManager, tea.Cmd) <span class="cov8" title="1">{
        switch msg.(type) </span>{
        case ToastTickMsg:<span class="cov8" title="1">
                if tm.IsVisible() &amp;&amp; tm.current != nil </span><span class="cov8" title="1">{
                        elapsed := time.Since(tm.current.CreatedAt)

                        fadeInDuration := 1000 * time.Millisecond   // 1 second fade-in
                        visibleDuration := 3000 * time.Millisecond  // 3 seconds fully visible
                        fadeOutDuration := 1000 * time.Millisecond  // 1 second fade-out
                        totalDuration := fadeInDuration + visibleDuration + fadeOutDuration

                        if elapsed &lt; fadeInDuration </span><span class="cov8" title="1">{
                                // Fade-in phase: 0 -&gt; 1
                                tm.opacity = float64(elapsed) / float64(fadeInDuration)
                        }</span> else<span class="cov8" title="1"> if elapsed &lt; fadeInDuration+visibleDuration </span><span class="cov8" title="1">{
                                // Fully visible phase
                                tm.opacity = 1.0
                        }</span> else<span class="cov8" title="1"> if elapsed &lt; totalDuration </span><span class="cov8" title="1">{
                                // Fade-out phase: 1 -&gt; 0
                                fadeOutElapsed := elapsed - (fadeInDuration + visibleDuration)
                                tm.opacity = 1.0 - (float64(fadeOutElapsed) / float64(fadeOutDuration))
                        }</span> else<span class="cov8" title="1"> {
                                // Animation complete, dismiss
                                tm.Dismiss()
                                return tm, nil
                        }</span>

                        // Keep ticking
                        <span class="cov8" title="1">return tm, tm.TickCmd()</span>
                }
        }
        <span class="cov0" title="0">return tm, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package main

import (
        "fmt"
        "os"

        tea "github.com/charmbracelet/bubbletea"

        "github.com/infktd/devdash/internal/config"
        "github.com/infktd/devdash/internal/registry"
        "github.com/infktd/devdash/internal/scanner"
        "github.com/infktd/devdash/internal/ui"
)

func main() <span class="cov0" title="0">{
        // Load config
        cfg, err := config.Load(config.Path())
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error loading config: %v\n", err)
                os.Exit(1)
        }</span>

        // Load registry
        <span class="cov0" title="0">reg, err := registry.Load(registry.Path())
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error loading registry: %v\n", err)
                os.Exit(1)
        }</span>

        // Auto-discover projects if enabled
        <span class="cov0" title="0">if cfg.Projects.AutoDiscover </span><span class="cov0" title="0">{
                projects, err := scanner.Scan(cfg.Projects.ScanPaths, cfg.Projects.ScanDepth)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Warning: error during project scan: %v\n", err)
                }</span>
                <span class="cov0" title="0">for _, path := range projects </span><span class="cov0" title="0">{
                        reg.AddProject(path)
                }</span>
                // Save updated registry
                <span class="cov0" title="0">if err := registry.Save(registry.Path(), reg); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Warning: failed to save registry: %v\n", err)
                }</span>
        }

        // Run TUI with mouse support
        <span class="cov0" title="0">p := tea.NewProgram(
                ui.New(cfg, reg),
                tea.WithAltScreen(),
                tea.WithMouseCellMotion(), // Enable mouse motion tracking
        )
        if _, err := p.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
